"use strict";
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = void 0;
const crypto_1 = __importDefault(require("crypto"));
const helpers_1 = require("./helpers");
const logger_1 = require("./logger");
const splitStrategies_1 = require("./splitStrategies");
/**
 * A class representing a pool of Sui objects and gas coins.
 * Multiple pools are used by ExecutorServiceHandler to
 * execute transactions asynchronously.
 */
class Pool {
    constructor(keypair, objects, gasCoins, client) {
        this._keypair = keypair;
        this._objects = objects;
        this._gasCoins = gasCoins;
        this._cursor = null;
        this._objectGenerator = this.objectBatchGenerator({
            owner: this._keypair.toSuiAddress(),
            client: client,
        });
        this.id = Pool.generateShortGUID();
    }
    static generateShortGUID() {
        // Create a random value and hash it
        const randomValue = crypto_1.default.randomBytes(8).toString('hex');
        const hash = crypto_1.default.createHash('md5').update(randomValue).digest('hex');
        // Return a portion of the hash for brevity
        return hash.slice(0, 8);
    }
    /**
     * Creates a new Pool instance and fetches an initial batch of objects.
     * The objects are fetched so that the pool is ready to be split.
     * @param input - An object containing the keypair and client to use.
     * @returns A Promise that resolves with the newly created Pool instance.
     */
    static async full(input) {
        const { keypair } = input;
        const pool = new Pool(keypair, new Map(), new Map(), input.client);
        await pool.fetchObjects(); // fetch an initial batch of objects
        return pool;
    }
    /**
     * Fetches a batch of objects from the object generator and adds them to the pool.
     * Also extracts any gas coins associated with the objects and adds them to the pool's gas coin collection.
     * @returns A boolean indicating whether the fetch was successful or not.
     */
    async fetchObjects() {
        const ownedObjectsBatch = await this._objectGenerator.next();
        if (!ownedObjectsBatch) {
            logger_1.logger.log(logger_1.Level.error, 'Did not fetch any objects!', this.id);
            return false;
        }
        if (!ownedObjectsBatch.done && !ownedObjectsBatch.value) {
            logger_1.logger.log(logger_1.Level.error, 'Did not fetch any objects!', this.id);
            return false;
        }
        if (ownedObjectsBatch.done) {
            logger_1.logger.log(logger_1.Level.warn, 'End of cursor - No more objects to fetch!', this.id);
        }
        ownedObjectsBatch.value.forEach((value, key) => {
            this._objects.set(key, value);
        });
        Pool.extractCoins(ownedObjectsBatch.value).forEach((value, key) => {
            this._gasCoins.set(key, value);
        });
        logger_1.logger.log(logger_1.Level.debug, `Fetched ${ownedObjectsBatch.value.size} objects.`, this.id);
        return true;
    }
    /**
     * Creates a generator that yields batches of objects owned by the pool's creator.
     * @generator
     * @async
     * @param {Object} input - An object containing the owner and client parameters.
     * @param {string} input.owner - The owner of the objects to retrieve.
     * @param {SuiClient} input.client - The SuiClient instance to use for retrieving the objects.
     * @yields {Map<string, ObjectReference>} A Map containing the object references for each batch of objects retrieved.
     * @throws {Error} If an object's data is undefined.
     */
    async *objectBatchGenerator(input) {
        let resp;
        let tempObjects;
        do {
            tempObjects = new Map();
            resp = await input.client.getOwnedObjects({
                owner: input.owner,
                cursor: this._cursor,
                options: {
                    showContent: true,
                    showType: true,
                },
            });
            resp.data.forEach((obj) => {
                if (!obj.data) {
                    throw new Error(`Object data is undefined: ${obj.error}`);
                }
                let balance;
                const content = obj.data.content;
                if (typeof content === 'object' &&
                    content !== null &&
                    'fields' in content &&
                    'type' in content) {
                    const fields = content.fields;
                    if ('balance' in fields) {
                        balance = Number(fields.balance);
                    }
                }
                const objectReference = {
                    objectId: obj.data.objectId,
                    digest: obj.data.digest,
                    version: obj.data.version,
                    type: obj.data.type ?? '',
                    balance,
                };
                if (objectReference) {
                    tempObjects.set(objectReference.objectId, objectReference);
                }
            });
            yield tempObjects;
            this._cursor = resp?.nextCursor;
        } while (resp.hasNextPage);
    }
    /**
     * Lazily splits off a new Pool using the split strategy provided.
     * By lazy, we mean that the objects are fetched by the blockchain only when needed.
     * Initially, we try to split the pool using the objects that are already in the pool.
     * If the split strategy does not succeed/complete, then we fetch more objects and
     * try to split those as well. We repeat this process until the split strategy
     * succeeds, or we run out of objects to fetch.
     * @splitStrategy the strategy used to split the pool's objects and coins
     * @returns the new Pool with the objects and coins that were split off
     */
    async split(client, splitStrategy = new splitStrategies_1.DefaultSplitStrategy()) {
        logger_1.logger.log(logger_1.Level.debug, `Splitting pool with ${this._objects.size} objects.`, this.id);
        let fetchSuccess;
        if (this._objects.size === 0) {
            fetchSuccess = await this.fetchObjects();
            if (!fetchSuccess) {
                throw new Error(`Pool (id: ${this.id}) split: Could not fetch any objects`);
            }
        }
        // Split the pool's objects into a new pool
        const objectsToGiveToNewPool = new Map();
        const gasCoinsToGiveToNewPool = new Map();
        do {
            this.splitObjects(splitStrategy).forEach((value, key) => {
                objectsToGiveToNewPool.set(key, value);
            });
            Pool.extractCoins(objectsToGiveToNewPool).forEach((value, key) => {
                gasCoinsToGiveToNewPool.set(key, value);
            });
            if (splitStrategy.succeeded()) {
                break;
            }
            fetchSuccess = await this.fetchObjects();
        } while (!(splitStrategy.succeeded() || !fetchSuccess));
        if (!splitStrategy.succeeded()) {
            throw new Error(`Pool (id: ${this.id}) split: The split strategy did not succeed even having fetched all the objects.`);
        }
        const newPool = new Pool(this._keypair, objectsToGiveToNewPool, gasCoinsToGiveToNewPool, client);
        if (newPool.objects.size === 0) {
            logger_1.logger.log(logger_1.Level.warn, `Pool (id: ${this.id}): Failed to split. newPool does not contain any objects.`);
        }
        if (newPool.gasCoins.size === 0) {
            logger_1.logger.log(logger_1.Level.warn, `Pool (id: ${this.id}): Failed to split. newPool does not contain any gas coins.`);
            throw new Error(`Pool (id: ${this.id}): Failed to split. newPool does not contain any gas coins.`);
        }
        logger_1.logger.log(logger_1.Level.info, `Split completed: main pool (${this.id}) = ${this._objects.size} objects, new pool (${newPool.id}) = ${newPool._objects.size} objects`, this.id);
        // Update the pool's coins
        Pool.extractCoins(newPool.gasCoins).forEach((_value, key) => {
            this._gasCoins.delete(key);
        });
        return newPool;
    }
    /**
     * Splits off the pool's objects map into two new maps.
     * One for the current pool (the ones with the objects to keep),
     * and one for the new pool (the ones to give).
     * The split strategy determines in which map each object will be moved to.
     * @param splitStrategy determines which objects will be moved to the new pool.
     * @returns the map of objects that will be assigned to the new pool
     */
    splitObjects(splitStrategy) {
        const objects_to_keep = new Map();
        const objects_to_give = new Map();
        // Transform the map into an array of key-value pairs. It's easier to iterate.
        const objects_array = Array.from(this._objects, ([objectId, object]) => ({
            objectId,
            object,
        }));
        outside: while (objects_array.length !== 0) {
            const last_object_in_array = objects_array.pop();
            if (last_object_in_array === undefined) {
                logger_1.logger.log(logger_1.Level.warn, 'No more main pool objects. Terminating split.', this.id);
                break;
            }
            switch (splitStrategy.pred(last_object_in_array.object)) {
                case true: {
                    // Predicate returned true, so we move the object to the new pool
                    objects_to_give.set(last_object_in_array.objectId, last_object_in_array.object);
                    break;
                }
                case false: {
                    // Predicate returned false, so we keep the object in the current pool
                    const obj_keep = last_object_in_array;
                    objects_to_keep.set(obj_keep.objectId, obj_keep.object);
                    break;
                }
                case null: {
                    // The predicate returned null, so we stop the split, and keep
                    // all the remaining objects of the array in the current pool.
                    objects_array.forEach((obj) => {
                        objects_to_keep.set(obj.objectId, obj.object);
                    });
                    objects_to_keep.set(last_object_in_array.objectId, last_object_in_array.object);
                    break outside;
                }
            }
        }
        this._objects = objects_to_keep;
        return objects_to_give;
    }
    /**
     * Merges the objects of poolToMerge to this pool.
     * @param poolToMerge The pool whose objects will be merged to this pool.
     */
    merge(poolToMerge) {
        logger_1.logger.log(logger_1.Level.debug, `Merging with pool ${poolToMerge.id} of ${poolToMerge._objects.size} objects. Current pool has ${this._objects.size} objects.`, this.id);
        poolToMerge.objects.forEach((value, key) => {
            this._objects.set(key, value);
        });
        poolToMerge.deleteObjects();
        logger_1.logger.log(logger_1.Level.debug, `Merge complete: pool ${this.id} now has ${this._objects.size} objects.`, this.id);
    }
    /**
     * Signs and executes a transaction block using the provided client and options.
     * @param input An object containing the client, transaction block, options, and request type.
     * @returns A promise that resolves to a SuiTransactionBlockResponse object.
     * @throws An error if any of the objects in the transaction block are not owned by the pool's creator,
     * or if there are no SUI coins in the pool to use as gas payment,
     * or if the dry run of the transaction block fails.
     */
    async signAndExecuteTransactionBlock(input) {
        logger_1.logger.log(logger_1.Level.debug, `Starting signAndExecuteTransactionBlock: current objects pool size: ${this._objects.size}`, this.id);
        let { transactionBlockLambda, options, requestType } = input;
        // (0). Get the complete transaction block by building it using moveCalls
        // from inside its lambda.
        let transactionBlockComplete;
        if (transactionBlockLambda.lambdaArgs) {
            // Execute the lambda by looking up the object of the given type
            // in the lambdaArgs array, and pass the object id that was found
            // in the lambda.
            transactionBlockComplete = transactionBlockLambda.lambda(...transactionBlockLambda.lambdaArgs.map((arg) => {
                return this.getObjectOfType(arg);
            }));
        }
        else {
            transactionBlockComplete = transactionBlockLambda.lambda();
        }
        // (1). Check object ownership
        logger_1.logger.log(logger_1.Level.debug, 'Checking object ownership...', this.id);
        transactionBlockComplete.setSender(this.keypair.getPublicKey().toSuiAddress());
        if (!(await this.checkTotalOwnership(transactionBlockComplete, input.client))) {
            throw new Error("All objects of the transaction block must be owned by the pool's creator.");
        }
        /*
        (2). Select Gas: Use all the coins in the pool as gas payment.
        When each pool uses only its own coins, transaction blocks can be executed
        without interfering with one another, avoiding equivocation.
        */
        const coinsArray = Array.from(this._gasCoins.values());
        const NoSuiCoinFound = coinsArray.length === 0;
        logger_1.logger.log(logger_1.Level.debug, `Coins used as gas payment: ${JSON.stringify(coinsArray)}`, this.id);
        if (NoSuiCoinFound) {
            throw new Error('No SUI coins in the pool to use as gas payment.');
        }
        // Finally, set the gas payment to be done by the selected coins
        transactionBlockComplete.setGasPayment(coinsArray);
        /*
        (2.5). Dry run the transaction block to ensure that Pool has enough
         resources to run the transaction and also to get the required budget
         */
        logger_1.logger.log(logger_1.Level.debug, 'Dry running the transaction block...', this.id);
        const dryRunRes = await input.client.dryRunTransactionBlock({
            transactionBlock: await transactionBlockComplete.build({
                client: input.client,
            }),
        });
        if (dryRunRes.effects.status.status !== 'success') {
            throw new Error(`Dry run failed. ${dryRunRes.effects.status.error}`);
        }
        // (3). Run the transaction
        const res = await input.client.signAndExecuteTransactionBlock({
            transactionBlock: transactionBlockComplete,
            requestType,
            options: {
                ...options,
                showEffects: true,
                showObjectChanges: true,
            },
            signer: this._keypair,
        });
        const created = res.effects?.created;
        const unwrapped = res.effects?.unwrapped;
        const mutated = res.effects?.mutated;
        const wrapped = res.effects?.wrapped;
        const deleted = res.effects?.deleted;
        logger_1.logger.log(logger_1.Level.debug, `Transaction block executed. Created: ${JSON.stringify(created)}, Unwrapped: ${JSON.stringify(unwrapped)}, Mutated: ${JSON.stringify(mutated)}, Wrapped: ${JSON.stringify(wrapped)}, Deleted: ${JSON.stringify(deleted)}`, this.id);
        // (4). Update the pool's objects and coins
        logger_1.logger.log(logger_1.Level.debug, 'Updating pool...', this.id);
        this.updatePool(created);
        this.updatePool(unwrapped);
        this.updatePool(mutated);
        this.removeFromPool(wrapped);
        this.removeFromPool(deleted);
        if (mutated) {
            await this.updateCoins(mutated, input.client);
        }
        logger_1.logger.log(logger_1.Level.debug, `Pool updated. Current pool has ${this._objects.size} objects.`, this.id);
        return res;
    }
    /**
     * After the transaction block execution, updates the pool with new references,
     * if the owner of the reference is the same as the signer address.
     * @param newRefs An array of OwnedObjectRef objects representing the new references to add to the pool.
     */
    updatePool(newRefs) {
        const signerAddress = this._keypair.getPublicKey().toSuiAddress();
        if (!newRefs)
            return;
        for (const ref in newRefs) {
            const objectOwner = newRefs[ref].owner
                .AddressOwner;
            const object = newRefs[ref].reference;
            const objectId = object.objectId;
            if (objectOwner != signerAddress) {
                return;
            }
            const toUpdate = {
                ...object,
                type: this._objects.get(objectId)?.type ?? '',
            };
            this._objects.set(objectId, toUpdate);
        }
    }
    /**
     * Removes the given object references from the pool.
     * Called after a transaction block execution for wrapped or deleted objects.
     * @param newRefs - The object references to remove from the pool.
     */
    removeFromPool(newRefs) {
        if (!newRefs)
            return;
        for (const ref of newRefs) {
            const objectId = ref.objectId;
            this._objects.delete(objectId);
        }
    }
    async updateCoins(mutated, client) {
        const mutatedCoinsObjectIds = mutated
            .filter((mutatedCoin) => {
            return this._gasCoins.has(mutatedCoin.reference.objectId);
        })
            .map((mutatedCoin) => {
            return mutatedCoin.reference.objectId;
        });
        const mutatedCoinsOnChainContents = await client.multiGetObjects({
            ids: mutatedCoinsObjectIds,
            options: { showContent: true },
        });
        mutatedCoinsOnChainContents.forEach((mutatedCoinObject) => {
            if ('data' in mutatedCoinObject &&
                'content' in mutatedCoinObject.data &&
                'fields' in mutatedCoinObject.data.content &&
                'balance' in mutatedCoinObject.data.content.fields) {
                const objectId = mutatedCoinObject.data.objectId;
                const balance = Number(mutatedCoinObject.data.content.fields.balance);
                const coin = this._gasCoins.get(objectId);
                if (!coin) {
                    const err = `Coin ${objectId} not found in the pool.`;
                    logger_1.logger.log(logger_1.Level.error, err);
                    throw new Error(err);
                }
                coin.balance = balance;
                coin.version = mutatedCoinObject.data.version;
                coin.digest = mutatedCoinObject.data.digest;
                this._gasCoins.set(coin.objectId, coin);
            }
        });
    }
    /**
     * Checks if all inputs in the transaction block are owned by the pool's creator or are immutable.
     * @param txb - The transaction block to check.
     * @param client - The SuiClient instance to use for checking immutability.
     * @returns A Promise that resolves to a boolean indicating whether all inputs are owned by the pool's creator or are immutable.
     */
    async checkTotalOwnership(txb, client) {
        await txb.build({ client });
        const ownedInputs = txb.blockData.inputs.filter((input) => {
            return (input.type === 'object' &&
                ('Object' in input.value || 'Input' in input.value) &&
                'ImmOrOwned' in input.value.Object);
        });
        return ownedInputs.every(async (ownedInput) => {
            const objID = ownedInput.value.Object.ImmOrOwned.objectId;
            const isInsidePool = this.isInsidePool(objID);
            const notInsidePool = !isInsidePool;
            if (notInsidePool) {
                const immutable = await (0, helpers_1.isImmutable)(objID, client);
                if (immutable) {
                    return true;
                }
                else {
                    console.error(`Object ${objID} is not owned by the pool's creator.`);
                }
            }
            return isInsidePool;
        });
    }
    /**
     * Check if the id of an object is in the object pool.
     * @param id the object id to check
     * @returns true if the object is in the pool, false otherwise
     */
    isInsidePool(id) {
        return this._objects.has(id);
    }
    get objects() {
        return this._objects;
    }
    get gasCoins() {
        return this._gasCoins;
    }
    deleteObjects() {
        this._objects.clear();
    }
    /**
     * Filters all the coins from pool's objects.
     * @param fromObjects - The pool of objects to extract coins from.
     * @returns A new pool of objects containing only the coins.
     * @throws An error if there are no coins in the pool.
     */
    static extractCoins(fromObjects) {
        const coinsMap = new Map();
        for (const [key, value] of fromObjects) {
            if ((0, helpers_1.isCoin)(value.type)) {
                coinsMap.set(key, value);
            }
        }
        if (!coinsMap) {
            throw new Error('No gas coins in the pool.');
        }
        return coinsMap;
    }
    /**
     * Looks up the pool for an object of the given type
     * and returns its object id.
     * @param type
     * @private
     */
    getObjectOfType(type) {
        const objectEntry = Array.from(this._objects.entries()).find(([key, value]) => {
            if (value.type.includes(type)) {
                return key;
            }
        });
        const objectId = objectEntry?.[0];
        if (!objectId) {
            throw new Error(`No ${type} found in the pool.`);
        }
        return objectId;
    }
    get keypair() {
        return this._keypair;
    }
    set keypair(value) {
        this._keypair = value;
    }
}
exports.Pool = Pool;
//# sourceMappingURL=pool.js.map