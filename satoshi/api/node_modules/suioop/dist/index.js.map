{"version":3,"sources":["../src/index.ts","../src/logger.ts","../src/pool.ts","../src/helpers.ts","../src/splitStrategies.ts","../src/executorServiceHandler.ts","../src/transactions.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\nexport * from './executorServiceHandler';\r\nexport * from './helpers';\r\nexport { Level } from './logger';\r\nexport * from './pool';\r\nexport * from './splitStrategies';\r\nexport * from './types';\r\nexport * from './transactions';\r\n","// Copyright (c) Mysten Labs, Inc.\r\n// SPDX-License-Identifier: Apache-2.0\r\nimport dotenv from 'dotenv';\r\nimport path from 'path';\r\nimport { pino } from 'pino';\r\n\r\nexport enum Level {\r\n  fatal = 'fatal',\r\n  error = 'error',\r\n  warn = 'warn',\r\n  info = 'info',\r\n  debug = 'debug',\r\n  trace = 'trace',\r\n  silent = 'silent', // use this to disable logging\r\n}\r\n\r\n/**\r\n * Singleton class to handle logging\r\n */\r\nclass Logger {\r\n  private static levelsTranslator: { [key: number]: string } = {\r\n    10: 'trace',\r\n    20: 'debug',\r\n    30: 'info',\r\n    40: 'warn',\r\n    50: 'error',\r\n    60: 'fatal',\r\n  };\r\n\r\n  private static instance: Logger;\r\n  private logger: pino.Logger;\r\n  private constructor(level: Level) {\r\n    const pinoLogger = pino(\r\n      {\r\n        base: null,\r\n        level,\r\n        timestamp: () => `,\"time\":\"${new Date().toISOString()}\"`,\r\n        pool_id: (id: string) => id,\r\n        formatters: {\r\n          level(label, number) {\r\n            return { level: Logger.levelsTranslator[number] };\r\n          },\r\n          log(object) {\r\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n            const { ...rest } = object;\r\n            return rest;\r\n          },\r\n        },\r\n        depthLimit: 10,\r\n      },\r\n      process.stdout,\r\n    );\r\n    this.logger = pinoLogger;\r\n    Logger.instance = this;\r\n  }\r\n\r\n  /**\r\n   * Initialize the logger instance.\r\n   * @param level {Level} - The minimum level to log.\r\n   */\r\n  public static initialize(level: Level = Level.error) {\r\n    if (!Logger.instance) {\r\n      new Logger(level);\r\n      return Logger.instance;\r\n    }\r\n    return Logger.instance;\r\n  }\r\n\r\n  /**\r\n   * Wrapper method for the logging-library's log function.\r\n   * @param level {Level} - The level to log at.\r\n   * @param msg {string} - The message regarding the log.\r\n   * @param pool_id {string} - The pool id to log; Used for tracing.\r\n   */\r\n  public log(level: Level = Level.info, msg: string, pool_id?: string): void {\r\n    Logger.instance.logger[level]({ msg, pool_id });\r\n  }\r\n}\r\n\r\ndotenv.config({\r\n  path: path.resolve(__dirname, '../test/.test.env'),\r\n});\r\nexport const logger = Logger.initialize(process.env.LOGGING_LEVEL as Level);\r\n","// Copyright (c) Mysten Labs, Inc.\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\nimport type {\r\n  ExecuteTransactionRequestType,\r\n  MoveStruct,\r\n  OwnedObjectRef,\r\n  PaginatedObjectsResponse,\r\n  SuiClient,\r\n  SuiObjectRef,\r\n  SuiObjectResponse,\r\n  SuiTransactionBlockResponse,\r\n  SuiTransactionBlockResponseOptions,\r\n} from '@mysten/sui.js/client';\r\nimport type { Keypair } from '@mysten/sui.js/cryptography';\r\nimport type { TransactionBlock } from '@mysten/sui.js/transactions';\r\nimport crypto from 'crypto';\r\n\r\nimport { isCoin, isImmutable } from './helpers';\r\nimport { Level, logger } from './logger';\r\nimport type { SplitStrategy } from './splitStrategies';\r\nimport { DefaultSplitStrategy } from './splitStrategies';\r\nimport type { PoolObject, PoolObjectsMap } from './types';\r\nimport type { TransactionBlockWithLambda } from './transactions';\r\n\r\n/**\r\n * A class representing a pool of Sui objects and gas coins.\r\n * Multiple pools are used by ExecutorServiceHandler to\r\n * execute transactions asynchronously.\r\n */\r\nexport class Pool {\r\n  public readonly id: string;\r\n  private _cursor: string | undefined | null;\r\n  private readonly _objectGenerator: AsyncGenerator<PoolObjectsMap>;\r\n  private _keypair: Keypair;\r\n  private _objects: PoolObjectsMap;\r\n  private _gasCoins: PoolObjectsMap;\r\n\r\n  private constructor(\r\n    keypair: Keypair,\r\n    objects: PoolObjectsMap,\r\n    gasCoins: PoolObjectsMap,\r\n    client: SuiClient,\r\n  ) {\r\n    this._keypair = keypair;\r\n    this._objects = objects;\r\n    this._gasCoins = gasCoins;\r\n    this._cursor = null;\r\n    this._objectGenerator = this.objectBatchGenerator({\r\n      owner: this._keypair.toSuiAddress(),\r\n      client: client,\r\n    });\r\n    this.id = Pool.generateShortGUID();\r\n  }\r\n  public static generateShortGUID() {\r\n    // Create a random value and hash it\r\n    const randomValue = crypto.randomBytes(8).toString('hex');\r\n    const hash = crypto.createHash('md5').update(randomValue).digest('hex');\r\n    // Return a portion of the hash for brevity\r\n    return hash.slice(0, 8);\r\n  }\r\n\r\n  /**\r\n   * Creates a new Pool instance and fetches an initial batch of objects.\r\n   * The objects are fetched so that the pool is ready to be split.\r\n   * @param input - An object containing the keypair and client to use.\r\n   * @returns A Promise that resolves with the newly created Pool instance.\r\n   */\r\n  static async full(input: { keypair: Keypair; client: SuiClient }) {\r\n    const { keypair } = input;\r\n    const pool = new Pool(keypair, new Map(), new Map(), input.client);\r\n    await pool.fetchObjects(); // fetch an initial batch of objects\r\n    return pool;\r\n  }\r\n\r\n  /**\r\n   * Fetches a batch of objects from the object generator and adds them to the pool.\r\n   * Also extracts any gas coins associated with the objects and adds them to the pool's gas coin collection.\r\n   * @returns A boolean indicating whether the fetch was successful or not.\r\n   */\r\n  private async fetchObjects() {\r\n    const ownedObjectsBatch = await this._objectGenerator.next();\r\n    if (!ownedObjectsBatch) {\r\n      logger.log(Level.error, 'Did not fetch any objects!', this.id);\r\n      return false;\r\n    }\r\n    if (!ownedObjectsBatch.done && !ownedObjectsBatch.value) {\r\n      logger.log(Level.error, 'Did not fetch any objects!', this.id);\r\n      return false;\r\n    }\r\n    if (ownedObjectsBatch.done) {\r\n      logger.log(\r\n        Level.warn,\r\n        'End of cursor - No more objects to fetch!',\r\n        this.id,\r\n      );\r\n    }\r\n    ownedObjectsBatch.value.forEach((value: PoolObject, key: string) => {\r\n      this._objects.set(key, value);\r\n    });\r\n    Pool.extractCoins(ownedObjectsBatch.value).forEach((value, key) => {\r\n      this._gasCoins.set(key, value);\r\n    });\r\n    logger.log(\r\n      Level.debug,\r\n      `Fetched ${ownedObjectsBatch.value.size} objects.`,\r\n      this.id,\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Creates a generator that yields batches of objects owned by the pool's creator.\r\n   * @generator\r\n   * @async\r\n   * @param {Object} input - An object containing the owner and client parameters.\r\n   * @param {string} input.owner - The owner of the objects to retrieve.\r\n   * @param {SuiClient} input.client - The SuiClient instance to use for retrieving the objects.\r\n   * @yields {Map<string, ObjectReference>} A Map containing the object references for each batch of objects retrieved.\r\n   * @throws {Error} If an object's data is undefined.\r\n   */\r\n  public async *objectBatchGenerator(input: {\r\n    owner: string;\r\n    client: SuiClient;\r\n  }) {\r\n    let resp: PaginatedObjectsResponse | null;\r\n    let tempObjects: PoolObjectsMap;\r\n    do {\r\n      tempObjects = new Map();\r\n      resp = await input.client.getOwnedObjects({\r\n        owner: input.owner,\r\n        cursor: this._cursor,\r\n        options: {\r\n          showContent: true,\r\n          showType: true,\r\n        },\r\n      });\r\n      resp.data.forEach((obj: SuiObjectResponse) => {\r\n        if (!obj.data) {\r\n          throw new Error(`Object data is undefined: ${obj.error}`);\r\n        }\r\n        let balance;\r\n        const content = obj.data.content;\r\n        if (\r\n          typeof content === 'object' &&\r\n          content !== null &&\r\n          'fields' in content &&\r\n          'type' in content\r\n        ) {\r\n          const fields: MoveStruct = content.fields;\r\n          if ('balance' in fields) {\r\n            balance = Number(fields.balance);\r\n          }\r\n        }\r\n        const objectReference = {\r\n          objectId: obj.data.objectId,\r\n          digest: obj.data.digest,\r\n          version: obj.data.version,\r\n          type: obj.data.type ?? '',\r\n          balance,\r\n        };\r\n        if (objectReference) {\r\n          tempObjects.set(objectReference.objectId, objectReference);\r\n        }\r\n      });\r\n      yield tempObjects;\r\n      this._cursor = resp?.nextCursor;\r\n    } while (resp.hasNextPage);\r\n  }\r\n\r\n  /**\r\n   * Lazily splits off a new Pool using the split strategy provided.\r\n   * By lazy, we mean that the objects are fetched by the blockchain only when needed.\r\n   * Initially, we try to split the pool using the objects that are already in the pool.\r\n   * If the split strategy does not succeed/complete, then we fetch more objects and\r\n   * try to split those as well. We repeat this process until the split strategy\r\n   * succeeds, or we run out of objects to fetch.\r\n   * @splitStrategy the strategy used to split the pool's objects and coins\r\n   * @returns the new Pool with the objects and coins that were split off\r\n   */\r\n  async split(\r\n    client: SuiClient,\r\n    splitStrategy: SplitStrategy = new DefaultSplitStrategy(),\r\n  ) {\r\n    logger.log(\r\n      Level.debug,\r\n      `Splitting pool with ${this._objects.size} objects.`,\r\n      this.id,\r\n    );\r\n    let fetchSuccess;\r\n    if (this._objects.size === 0) {\r\n      fetchSuccess = await this.fetchObjects();\r\n      if (!fetchSuccess) {\r\n        throw new Error(\r\n          `Pool (id: ${this.id}) split: Could not fetch any objects`,\r\n        );\r\n      }\r\n    }\r\n    // Split the pool's objects into a new pool\r\n    const objectsToGiveToNewPool: PoolObjectsMap = new Map();\r\n    const gasCoinsToGiveToNewPool: PoolObjectsMap = new Map();\r\n    do {\r\n      this.splitObjects(splitStrategy).forEach((value, key) => {\r\n        objectsToGiveToNewPool.set(key, value);\r\n      });\r\n      Pool.extractCoins(objectsToGiveToNewPool).forEach((value, key) => {\r\n        gasCoinsToGiveToNewPool.set(key, value);\r\n      });\r\n      if (splitStrategy.succeeded()) {\r\n        break;\r\n      }\r\n      fetchSuccess = await this.fetchObjects();\r\n    } while (!(splitStrategy.succeeded() || !fetchSuccess));\r\n    if (!splitStrategy.succeeded()) {\r\n      throw new Error(\r\n        `Pool (id: ${this.id}) split: The split strategy did not succeed even having fetched all the objects.`,\r\n      );\r\n    }\r\n    const newPool = new Pool(\r\n      this._keypair,\r\n      objectsToGiveToNewPool,\r\n      gasCoinsToGiveToNewPool,\r\n      client,\r\n    );\r\n    if (newPool.objects.size === 0) {\r\n      logger.log(\r\n        Level.warn,\r\n        `Pool (id: ${this.id}): Failed to split. newPool does not contain any objects.`,\r\n      );\r\n    }\r\n    if (newPool.gasCoins.size === 0) {\r\n      logger.log(\r\n        Level.warn,\r\n        `Pool (id: ${this.id}): Failed to split. newPool does not contain any gas coins.`,\r\n      );\r\n      throw new Error(\r\n        `Pool (id: ${this.id}): Failed to split. newPool does not contain any gas coins.`,\r\n      );\r\n    }\r\n    logger.log(\r\n      Level.info,\r\n      `Split completed: main pool (${this.id}) = ${this._objects.size} objects, new pool (${newPool.id}) = ${newPool._objects.size} objects`,\r\n      this.id,\r\n    );\r\n    // Update the pool's coins\r\n    Pool.extractCoins(newPool.gasCoins).forEach((_value, key) => {\r\n      this._gasCoins.delete(key);\r\n    });\r\n    return newPool;\r\n  }\r\n\r\n  /**\r\n   * Splits off the pool's objects map into two new maps.\r\n   * One for the current pool (the ones with the objects to keep),\r\n   * and one for the new pool (the ones to give).\r\n   * The split strategy determines in which map each object will be moved to.\r\n   * @param splitStrategy determines which objects will be moved to the new pool.\r\n   * @returns the map of objects that will be assigned to the new pool\r\n   */\r\n  splitObjects(splitStrategy: SplitStrategy): PoolObjectsMap {\r\n    const objects_to_keep: PoolObjectsMap = new Map();\r\n    const objects_to_give: PoolObjectsMap = new Map();\r\n\r\n    // Transform the map into an array of key-value pairs. It's easier to iterate.\r\n    const objects_array = Array.from(this._objects, ([objectId, object]) => ({\r\n      objectId,\r\n      object,\r\n    }));\r\n    outside: while (objects_array.length !== 0) {\r\n      const last_object_in_array = objects_array.pop();\r\n      if (last_object_in_array === undefined) {\r\n        logger.log(\r\n          Level.warn,\r\n          'No more main pool objects. Terminating split.',\r\n          this.id,\r\n        );\r\n        break;\r\n      }\r\n      switch (splitStrategy.pred(last_object_in_array.object)) {\r\n        case true: {\r\n          // Predicate returned true, so we move the object to the new pool\r\n          objects_to_give.set(\r\n            last_object_in_array.objectId,\r\n            last_object_in_array.object,\r\n          );\r\n          break;\r\n        }\r\n        case false: {\r\n          // Predicate returned false, so we keep the object in the current pool\r\n          const obj_keep = last_object_in_array;\r\n          objects_to_keep.set(obj_keep.objectId, obj_keep.object);\r\n          break;\r\n        }\r\n        case null: {\r\n          // The predicate returned null, so we stop the split, and keep\r\n          // all the remaining objects of the array in the current pool.\r\n          objects_array.forEach((obj) => {\r\n            objects_to_keep.set(obj.objectId, obj.object);\r\n          });\r\n          objects_to_keep.set(\r\n            last_object_in_array.objectId,\r\n            last_object_in_array.object,\r\n          );\r\n          break outside;\r\n        }\r\n      }\r\n    }\r\n    this._objects = objects_to_keep;\r\n    return objects_to_give;\r\n  }\r\n\r\n  /**\r\n   * Merges the objects of poolToMerge to this pool.\r\n   * @param poolToMerge The pool whose objects will be merged to this pool.\r\n   */\r\n  public merge(poolToMerge: Pool) {\r\n    logger.log(\r\n      Level.debug,\r\n      `Merging with pool ${poolToMerge.id} of ${poolToMerge._objects.size} objects. Current pool has ${this._objects.size} objects.`,\r\n      this.id,\r\n    );\r\n    poolToMerge.objects.forEach((value, key) => {\r\n      this._objects.set(key, value);\r\n    });\r\n    poolToMerge.deleteObjects();\r\n    logger.log(\r\n      Level.debug,\r\n      `Merge complete: pool ${this.id} now has ${this._objects.size} objects.`,\r\n      this.id,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Signs and executes a transaction block using the provided client and options.\r\n   * @param input An object containing the client, transaction block, options, and request type.\r\n   * @returns A promise that resolves to a SuiTransactionBlockResponse object.\r\n   * @throws An error if any of the objects in the transaction block are not owned by the pool's creator,\r\n   * or if there are no SUI coins in the pool to use as gas payment,\r\n   * or if the dry run of the transaction block fails.\r\n   */\r\n  async signAndExecuteTransactionBlock(input: {\r\n    client: SuiClient;\r\n    transactionBlockLambda: TransactionBlockWithLambda;\r\n    options?: SuiTransactionBlockResponseOptions;\r\n    requestType?: ExecuteTransactionRequestType;\r\n  }): Promise<SuiTransactionBlockResponse> {\r\n    logger.log(\r\n      Level.debug,\r\n      `Starting signAndExecuteTransactionBlock: current objects pool size: ${this._objects.size}`,\r\n      this.id,\r\n    );\r\n    let { transactionBlockLambda, options, requestType } = input;\r\n\r\n    // (0). Get the complete transaction block by building it using moveCalls\r\n    // from inside its lambda.\r\n    let transactionBlockComplete: TransactionBlock;\r\n    if (transactionBlockLambda.lambdaArgs) {\r\n      // Execute the lambda by looking up the object of the given type\r\n      // in the lambdaArgs array, and pass the object id that was found\r\n      // in the lambda.\r\n      transactionBlockComplete = transactionBlockLambda.lambda(\r\n        ...transactionBlockLambda.lambdaArgs.map((arg) => {\r\n          return this.getObjectOfType(arg);\r\n        }),\r\n      );\r\n    } else {\r\n      transactionBlockComplete = transactionBlockLambda.lambda();\r\n    }\r\n\r\n    // (1). Check object ownership\r\n    logger.log(Level.debug, 'Checking object ownership...', this.id);\r\n    transactionBlockComplete.setSender(\r\n      this.keypair.getPublicKey().toSuiAddress(),\r\n    );\r\n    if (\r\n      !(await this.checkTotalOwnership(transactionBlockComplete, input.client))\r\n    ) {\r\n      throw new Error(\r\n        \"All objects of the transaction block must be owned by the pool's creator.\",\r\n      );\r\n    }\r\n\r\n    /*\r\n    (2). Select Gas: Use all the coins in the pool as gas payment.\r\n    When each pool uses only its own coins, transaction blocks can be executed\r\n    without interfering with one another, avoiding equivocation.\r\n    */\r\n    const coinsArray = Array.from(this._gasCoins.values());\r\n    const NoSuiCoinFound = coinsArray.length === 0;\r\n    logger.log(\r\n      Level.debug,\r\n      `Coins used as gas payment: ${JSON.stringify(coinsArray)}`,\r\n      this.id,\r\n    );\r\n    if (NoSuiCoinFound) {\r\n      throw new Error('No SUI coins in the pool to use as gas payment.');\r\n    }\r\n    // Finally, set the gas payment to be done by the selected coins\r\n    transactionBlockComplete.setGasPayment(coinsArray);\r\n\r\n    /*\r\n    (2.5). Dry run the transaction block to ensure that Pool has enough\r\n     resources to run the transaction and also to get the required budget\r\n     */\r\n    logger.log(Level.debug, 'Dry running the transaction block...', this.id);\r\n    const dryRunRes = await input.client.dryRunTransactionBlock({\r\n      transactionBlock: await transactionBlockComplete.build({\r\n        client: input.client,\r\n      }),\r\n    });\r\n    if (dryRunRes.effects.status.status !== 'success') {\r\n      throw new Error(`Dry run failed. ${dryRunRes.effects.status.error}`);\r\n    }\r\n\r\n    // (3). Run the transaction\r\n    const res = await input.client.signAndExecuteTransactionBlock({\r\n      transactionBlock: transactionBlockComplete,\r\n      requestType,\r\n      options: {\r\n        ...options,\r\n        showEffects: true,\r\n        showObjectChanges: true,\r\n      },\r\n      signer: this._keypair,\r\n    });\r\n\r\n    const created = res.effects?.created;\r\n    const unwrapped = res.effects?.unwrapped;\r\n    const mutated = res.effects?.mutated;\r\n    const wrapped = res.effects?.wrapped;\r\n    const deleted = res.effects?.deleted;\r\n    logger.log(\r\n      Level.debug,\r\n      `Transaction block executed. Created: ${JSON.stringify(\r\n        created,\r\n      )}, Unwrapped: ${JSON.stringify(unwrapped)}, Mutated: ${JSON.stringify(\r\n        mutated,\r\n      )}, Wrapped: ${JSON.stringify(wrapped)}, Deleted: ${JSON.stringify(\r\n        deleted,\r\n      )}`,\r\n      this.id,\r\n    );\r\n\r\n    // (4). Update the pool's objects and coins\r\n    logger.log(Level.debug, 'Updating pool...', this.id);\r\n\r\n    this.updatePool(created);\r\n    this.updatePool(unwrapped);\r\n    this.updatePool(mutated);\r\n\r\n    this.removeFromPool(wrapped);\r\n    this.removeFromPool(deleted);\r\n\r\n    if (mutated) {\r\n      await this.updateCoins(mutated, input.client);\r\n    }\r\n\r\n    logger.log(\r\n      Level.debug,\r\n      `Pool updated. Current pool has ${this._objects.size} objects.`,\r\n      this.id,\r\n    );\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * After the transaction block execution, updates the pool with new references,\r\n   * if the owner of the reference is the same as the signer address.\r\n   * @param newRefs An array of OwnedObjectRef objects representing the new references to add to the pool.\r\n   */\r\n  private updatePool(newRefs: OwnedObjectRef[] | undefined) {\r\n    const signerAddress = this._keypair.getPublicKey().toSuiAddress();\r\n    if (!newRefs) return;\r\n    for (const ref in newRefs) {\r\n      const objectOwner = (newRefs[ref].owner as { AddressOwner: string })\r\n        .AddressOwner;\r\n      const object = newRefs[ref].reference;\r\n      const objectId = object.objectId;\r\n      if (objectOwner != signerAddress) {\r\n        return;\r\n      }\r\n      const toUpdate = {\r\n        ...object,\r\n        type: this._objects.get(objectId)?.type ?? '',\r\n      };\r\n      this._objects.set(objectId, toUpdate as PoolObject);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the given object references from the pool.\r\n   * Called after a transaction block execution for wrapped or deleted objects.\r\n   * @param newRefs - The object references to remove from the pool.\r\n   */\r\n  private removeFromPool(newRefs: SuiObjectRef[] | undefined) {\r\n    if (!newRefs) return;\r\n    for (const ref of newRefs) {\r\n      const objectId = ref.objectId;\r\n      this._objects.delete(objectId);\r\n    }\r\n  }\r\n\r\n  private async updateCoins(mutated: OwnedObjectRef[], client: SuiClient) {\r\n    const mutatedCoinsObjectIds = mutated\r\n      .filter((mutatedCoin) => {\r\n        return this._gasCoins.has(mutatedCoin.reference.objectId);\r\n      })\r\n      .map((mutatedCoin) => {\r\n        return mutatedCoin.reference.objectId;\r\n      });\r\n    const mutatedCoinsOnChainContents = await client.multiGetObjects({\r\n      ids: mutatedCoinsObjectIds,\r\n      options: { showContent: true },\r\n    });\r\n    mutatedCoinsOnChainContents.forEach((mutatedCoinObject) => {\r\n      if (\r\n        'data' in mutatedCoinObject &&\r\n        'content' in mutatedCoinObject.data! &&\r\n        'fields' in mutatedCoinObject.data.content! &&\r\n        'balance' in mutatedCoinObject.data.content.fields\r\n      ) {\r\n        const objectId = mutatedCoinObject.data.objectId;\r\n        const balance = Number(mutatedCoinObject.data.content.fields.balance);\r\n        const coin = this._gasCoins.get(objectId);\r\n        if (!coin) {\r\n          const err = `Coin ${objectId} not found in the pool.`;\r\n          logger.log(Level.error, err);\r\n          throw new Error(err);\r\n        }\r\n        coin.balance = balance;\r\n        coin.version = mutatedCoinObject.data.version;\r\n        coin.digest = mutatedCoinObject.data.digest;\r\n        this._gasCoins.set(coin.objectId, coin);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Checks if all inputs in the transaction block are owned by the pool's creator or are immutable.\r\n   * @param txb - The transaction block to check.\r\n   * @param client - The SuiClient instance to use for checking immutability.\r\n   * @returns A Promise that resolves to a boolean indicating whether all inputs are owned by the pool's creator or are immutable.\r\n   */\r\n  public async checkTotalOwnership(\r\n    txb: TransactionBlock,\r\n    client: SuiClient,\r\n  ): Promise<boolean> {\r\n    await txb.build({ client });\r\n    const ownedInputs = txb.blockData.inputs.filter((input) => {\r\n      return (\r\n        input.type === 'object' &&\r\n        ('Object' in input.value || 'Input' in input.value) &&\r\n        'ImmOrOwned' in input.value.Object\r\n      );\r\n    });\r\n    return ownedInputs.every(async (ownedInput) => {\r\n      const objID = ownedInput.value.Object.ImmOrOwned.objectId;\r\n      const isInsidePool = this.isInsidePool(objID);\r\n      const notInsidePool = !isInsidePool;\r\n      if (notInsidePool) {\r\n        const immutable = await isImmutable(objID, client);\r\n        if (immutable) {\r\n          return true;\r\n        } else {\r\n          console.error(`Object ${objID} is not owned by the pool's creator.`);\r\n        }\r\n      }\r\n      return isInsidePool;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if the id of an object is in the object pool.\r\n   * @param id the object id to check\r\n   * @returns true if the object is in the pool, false otherwise\r\n   */\r\n  private isInsidePool(id: string): boolean {\r\n    return this._objects.has(id);\r\n  }\r\n\r\n  get objects(): PoolObjectsMap {\r\n    return this._objects;\r\n  }\r\n\r\n  get gasCoins(): PoolObjectsMap {\r\n    return this._gasCoins;\r\n  }\r\n  public deleteObjects() {\r\n    this._objects.clear();\r\n  }\r\n\r\n  /**\r\n   * Filters all the coins from pool's objects.\r\n   * @param fromObjects - The pool of objects to extract coins from.\r\n   * @returns A new pool of objects containing only the coins.\r\n   * @throws An error if there are no coins in the pool.\r\n   */\r\n  static extractCoins(fromObjects: PoolObjectsMap) {\r\n    const coinsMap: PoolObjectsMap = new Map();\r\n    for (const [key, value] of fromObjects) {\r\n      if (isCoin(value.type)) {\r\n        coinsMap.set(key, value);\r\n      }\r\n    }\r\n    if (!coinsMap) {\r\n      throw new Error('No gas coins in the pool.');\r\n    }\r\n    return coinsMap;\r\n  }\r\n\r\n  /**\r\n   * Looks up the pool for an object of the given type\r\n   * and returns its object id.\r\n   * @param type\r\n   * @private\r\n   */\r\n  private getObjectOfType(type: string): string {\r\n    const objectEntry = Array.from(this._objects.entries()).find(\r\n      ([key, value]) => {\r\n        if (value.type.includes(type)) {\r\n          return key;\r\n        }\r\n      },\r\n    );\r\n    const objectId = objectEntry?.[0];\r\n    if (!objectId) {\r\n      throw new Error(`No ${type} found in the pool.`);\r\n    }\r\n    return objectId;\r\n  }\r\n\r\n  get keypair(): Keypair {\r\n    return this._keypair;\r\n  }\r\n\r\n  set keypair(value: Keypair) {\r\n    this._keypair = value;\r\n  }\r\n}\r\n","// Copyright (c) Mysten Labs, Inc.\r\n// SPDX-License-Identifier: Apache-2.0\r\nimport type { SuiClient } from '@mysten/sui.js/client';\r\n\r\n/**\r\n * Checks if an object is \"Immutable\" by looking up its data on the blockchain.\r\n * @param objectId - The ID of the object to check.\r\n * @param client - The SuiClient instance to use for the API request.\r\n * @returns A Promise that resolves to a boolean indicating whether the object is owned by an \"Immutable\" owner.\r\n * @throws An error if the \"owner\" field of the object cannot be extracted.\r\n */\r\nexport async function isImmutable(objectId: string, client: SuiClient) {\r\n  const obj = await client.getObject({\r\n    id: objectId,\r\n    options: {\r\n      showOwner: true,\r\n    },\r\n  });\r\n  const objectOwner = obj?.data?.owner;\r\n  if (!objectOwner) {\r\n    throw new Error(`Could not extract \"owner\" field of object ${objectId}`);\r\n  }\r\n  return objectOwner == 'Immutable';\r\n}\r\n\r\n/**\r\n * Checks if the given object type is a coin.\r\n * Defaults to checking if the object type is a SUI (gas) coin.\r\n * @param objectType The object type to check.\r\n * @param ofType The expected object type.\r\n * @returns True if the object type is a coin, false otherwise.\r\n */\r\nexport function isCoin(\r\n  objectType: string,\r\n  ofType = '0x2::coin::Coin<0x2::sui::SUI>',\r\n) {\r\n  return objectType === ofType;\r\n}\r\n","// Copyright (c) Mysten Labs, Inc.\r\n// SPDX-License-Identifier: Apache-2.0\r\nimport { isCoin } from './helpers';\r\nimport type { PoolObject } from './types';\r\n\r\n/**\r\n * A strategy containing the rules that determine how the split of the pool will be done.\r\n *\r\n * - pred: A predicate function used to split the pool's objects and coins into a new pool.\r\n * This predicate is called for each object, and depending on what it returns,\r\n * the object will be moved to the new pool, stay in the current pool, or the split will be terminated.\r\n * The predicate should return:\r\n * 1. `true`, if the object will be moved to the new Pool\r\n * 2. `false`, if the object stays in `this` Pool\r\n * 3. `null`, if the split should be terminated and the new Pool should be returned immediately,\r\n * with the remaining unchecked objects being kept to the initial pool.\r\n *\r\n * [WARNING] If you want to implement a custom strategy, make sure that the predicate\r\n * will select at least one coin to be moved to the new pool, otherwise the transaction block\r\n * will not be able to determine the gas payment and will fail.\r\n *\r\n * - succeeded: A function that is called after the split is done to check if the split utilized the strategy as supposed to.\r\n */\r\nexport type SplitStrategy = {\r\n  pred: (obj: PoolObject | undefined) => boolean | null;\r\n\r\n  /**\r\n   * Call this function after the split is done to check if the split utilized the strategy as supposed to.\r\n   * Used in order to decide if it should be retried by loading more objects for the strategy to iterate over.\r\n   * @returns A boolean indicating if the split succeeded or not.\r\n   */\r\n  succeeded: () => boolean;\r\n};\r\n\r\n/**\r\n * The DefaultSplitStrategy is used when no other strategy is provided.\r\n * It moves to the new pool enough gas (SUI) coins so that the sum of their\r\n * balances is greater or equal a specific threshold.\r\n */\r\nexport class DefaultSplitStrategy implements SplitStrategy {\r\n  static readonly defaultMinimumBalance = 400000000;\r\n  private readonly minimumBalance;\r\n  private balanceSoFar = 0;\r\n\r\n  constructor(minimumBalance = DefaultSplitStrategy.defaultMinimumBalance) {\r\n    this.minimumBalance = minimumBalance;\r\n  }\r\n\r\n  public pred(obj: PoolObject | undefined) {\r\n    if (!obj) throw new Error('No object found!.');\r\n    if (this.balanceSoFar >= this.minimumBalance) {\r\n      return null;\r\n    }\r\n    if (isCoin(obj.type)) {\r\n      this.balanceSoFar += obj.balance ?? 0;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  public succeeded() {\r\n    return this.balanceSoFar >= this.minimumBalance;\r\n  }\r\n}\r\n\r\n/**\r\n * The IncludeAdminCapStrategy is used when the pool needs to contain an AdminCap object.\r\n * It moves to the new pool enough gas coins to fulfill the needed balance,\r\n * and one AdminCap object of the specified package.\r\n */\r\nexport class IncludeAdminCapStrategy implements SplitStrategy {\r\n  private readonly adminCapIdentifier: string;\r\n  private readonly packageId: string;\r\n\r\n  private readonly minimumBalance;\r\n  private balanceSoFar = 0;\r\n  private adminCapIncluded = false;\r\n\r\n  /**\r\n   * Creates a new instance of the Pool class.\r\n   * @param packageId - The ID of the package containing the AdminCap.\r\n   * @param minimumBalance - The minimum balance of the pool\r\n   * @param adminCapIdentifier - A name used to identify the AdminCap object.\r\n   * (pool balance = sum of its' gas coin balances).\r\n   */\r\n  constructor(\r\n    packageId: string,\r\n    minimumBalance = DefaultSplitStrategy.defaultMinimumBalance,\r\n    adminCapIdentifier = 'AdminCap',\r\n  ) {\r\n    this.packageId = packageId;\r\n    this.minimumBalance = minimumBalance;\r\n    this.adminCapIdentifier = adminCapIdentifier;\r\n  }\r\n  public pred(obj: PoolObject | undefined) {\r\n    if (!obj) throw new Error('No object found!.');\r\n    const terminateWhen =\r\n      this.balanceSoFar >= this.minimumBalance && this.adminCapIncluded;\r\n    if (terminateWhen) {\r\n      return null;\r\n    }\r\n    if (\r\n      !this.adminCapIncluded &&\r\n      obj.type.includes(this.adminCapIdentifier) &&\r\n      obj.type.includes(this.packageId)\r\n    ) {\r\n      this.adminCapIncluded = true;\r\n      return true;\r\n    }\r\n    if (!(this.balanceSoFar >= this.minimumBalance) && isCoin(obj.type)) {\r\n      this.balanceSoFar += obj.balance ?? 0;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  public succeeded() {\r\n    return this.balanceSoFar >= this.minimumBalance && this.adminCapIncluded;\r\n  }\r\n}\r\n","// Copyright (c) Mysten Labs, Inc.\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\nimport type {\r\n  ExecuteTransactionRequestType,\r\n  SuiClient,\r\n  SuiTransactionBlockResponse,\r\n  SuiTransactionBlockResponseOptions,\r\n} from '@mysten/sui.js/client';\r\nimport type { Keypair } from '@mysten/sui.js/cryptography';\r\n\r\nimport { Level, logger } from './logger';\r\nimport { Pool } from './pool';\r\nimport type { SplitStrategy } from './splitStrategies';\r\nimport type { TransactionBlockWithLambda } from './transactions';\r\n\r\n/**\r\n * A class that orchestrates the execution of transaction blocks using multiple worker pools.\r\n * The workers are created by splitting a main pool and are used to execute transaction blocks asynchronously without object equivocation.\r\n * [Note: ] The mainPool is not a worker pool and is not used for transaction block execution. It is used only for splitting.\r\n * The number of workers is not fixed and can be increased by splitting the main pool if the workload requires it.\r\n * The ExecutorServiceHandler retries the execution of the transaction block up to a specified number of times in case of errors.\r\n */\r\nexport class ExecutorServiceHandler {\r\n  private _mainPool: Pool; // shared resource between threads\r\n  private _workersQueue: Pool[] = []; // shared resource between threads\r\n  private _accessQueue = Promise.resolve(); // mutex for thread safety of mainPool access\r\n  private readonly _getWorkerTimeoutMs: number;\r\n  private constructor(mainPool: Pool, getWorkerTimeoutMs: number) {\r\n    this._mainPool = mainPool;\r\n    this._getWorkerTimeoutMs = getWorkerTimeoutMs;\r\n  }\r\n\r\n  /**\r\n   * Initializes an ExecutorServiceHandler instance.\r\n   * @param keypair - The keypair to use for authentication.\r\n   * @param client - The SuiClient instance to use for communication with the Sui network.\r\n   * @param getWorkerTimeoutMs - The maximum number of milliseconds to listen for an available\r\n   * worker from the worker queue.\r\n   * @returns A new ExecutorServiceHandler instance.\r\n   */\r\n  public static async initialize(\r\n    keypair: Keypair,\r\n    client: SuiClient,\r\n    getWorkerTimeoutMs = 10000,\r\n  ) {\r\n    const pool = await Pool.full({ keypair: keypair, client });\r\n    return new ExecutorServiceHandler(pool, getWorkerTimeoutMs);\r\n  }\r\n\r\n  /**\r\n   * Executes the given transaction block using the provided SuiClient and split strategy (if any).\r\n   * Retries the execution up to the specified number of times in case of errors.\r\n   *\r\n   * Note that the execution is asynchronous and the result is returned as a Promise.\r\n   * This means that you can execute multiple transaction blocks in parallel **without**\r\n   * equivocating objects, as long as the splitStrategy permits it.\r\n   * @param txb The transaction block to execute.\r\n   * @param client The SuiClient instance is to use it for execution.\r\n   * @param splitStrategy The SplitStrategy used to determine how a new worker pool will be split\r\n   * from the main pool in case a new worker is needed to execute the transaction.\r\n   * @param options (Optional) The SuiTransactionBlockResponseOptions to use for executing the transaction block.\r\n   * @param requestType (Optional) The ExecuteTransactionRequestType to use for executing the transaction block.\r\n   * @param retries The maximum number of retries in case of errors (default: 3).\r\n   * @returns A Promise that resolves to the result of the transaction block execution.\r\n   * @throws An error if all retries fail.\r\n   */\r\n  public async execute(\r\n    txb: TransactionBlockWithLambda,\r\n    client: SuiClient,\r\n    splitStrategy?: SplitStrategy,\r\n    options?: SuiTransactionBlockResponseOptions,\r\n    requestType?: ExecuteTransactionRequestType,\r\n    retries = 3,\r\n  ) {\r\n    let res;\r\n    const flowId = Pool.generateShortGUID();\r\n    do {\r\n      try {\r\n        res = await this.executeFlow(\r\n          flowId,\r\n          txb,\r\n          client,\r\n          splitStrategy,\r\n          options,\r\n          requestType,\r\n        );\r\n      } catch (e) {\r\n        logger.log(\r\n          Level.error,\r\n          `${flowId} - ESHandler: Error executing transaction block: ${e} - ${\r\n            retries - 1\r\n          } retries left...`,\r\n        );\r\n        continue;\r\n      }\r\n      if (res) {\r\n        logger.log(\r\n          Level.info,\r\n          `${flowId} - ESHandler: Transaction block execution completed - digest: ${JSON.stringify(\r\n            res.digest,\r\n          )}`,\r\n        );\r\n        return res;\r\n      }\r\n      logger.log(\r\n        Level.debug,\r\n        `${flowId} - ESHandler: Could not execute flow: unavailable worker - ${\r\n          retries - 1\r\n        } retries left...`,\r\n      );\r\n    } while (--retries > 0);\r\n    logger.log(\r\n      Level.error,\r\n      `${flowId} - ESHandler: executeFlowError - All retries failed: Could not execute the transaction block`,\r\n    );\r\n    throw new Error(\r\n      `${flowId} - ESHandler: executeFlowError - All retries failed: Could not execute the transaction block`,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Helper function of execute(). Contains the main logic for executing a transaction block,\r\n   * including getting an available worker from the workers array, updating the workerPool status, etc.\r\n   * @param flowId - flowId for logging purposes\r\n   * @param txb The transaction block to execute.\r\n   * @param client The SuiClient to use for executing the transaction block.\r\n   * @param options (Optional) The SuiTransactionBlockResponseOptions to use for executing the transaction block.\r\n   * @param requestType (Optional) The ExecuteTransactionRequestType to use for executing the transaction block.\r\n   * @param splitStrategy (Optional) The SplitStrategy to use for splitting the main pool and getting a new worker pool.\r\n   * @returns A Promise that resolves to the SuiTransactionBlockResponse object returned by executing the transaction block.\r\n   */\r\n  private async executeFlow(\r\n    flowId: string,\r\n    txb: TransactionBlockWithLambda,\r\n    client: SuiClient,\r\n    splitStrategy?: SplitStrategy,\r\n    options?: SuiTransactionBlockResponseOptions,\r\n    requestType?: ExecuteTransactionRequestType,\r\n  ) {\r\n    let worker: Pool | undefined;\r\n    try {\r\n      worker = await this.getAWorker(flowId);\r\n    } catch (e) {\r\n      worker = undefined;\r\n    }\r\n    const noWorkerAvailable = worker === undefined;\r\n    if (noWorkerAvailable) {\r\n      logger.log(\r\n        Level.debug,\r\n        `${flowId} - ESHandler: Could not find an available worker.`,\r\n      );\r\n      await this.passToAccessQueue(async () => {\r\n        await this.addWorker(flowId, client, splitStrategy);\r\n      });\r\n      return;\r\n    } else if (worker) {\r\n      logger.log(\r\n        Level.debug,\r\n        `${flowId} - ESHandler: Found an available worker: ${worker.id}. Executing transaction block...`,\r\n      );\r\n      let result: SuiTransactionBlockResponse;\r\n      try {\r\n        result = await worker.signAndExecuteTransactionBlock({\r\n          transactionBlockLambda: txb,\r\n          client: client,\r\n          options,\r\n          requestType,\r\n        });\r\n      } catch (e) {\r\n        logger.log(\r\n          Level.warn,\r\n          `${flowId} - ESHandler: Error executing transaction block: ${e}`,\r\n        );\r\n        await this.passToAccessQueue(async () => {\r\n          if (worker) {\r\n            this._mainPool.merge(worker);\r\n          }\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (result.effects && result.effects.status.status === 'failure') {\r\n        logger.log(\r\n          Level.error,\r\n          `${flowId} - ESHandler: Error executing transaction block: result status is \"failure\"`,\r\n        );\r\n        await this.passToAccessQueue(async () => {\r\n          if (worker) {\r\n            this._mainPool.merge(worker);\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      logger.log(\r\n        Level.debug,\r\n        `${flowId} - ESHandler: Transaction block execution completed! Pushing worker ${worker.id} back to the queue...`,\r\n      );\r\n      // Execution finished, the worker is now available again.\r\n      this._workersQueue.push(worker);\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an available worker from the worker queue, or undefined if none are available within the timeout period.\r\n   * @returns {Pool | undefined} - An available worker from the worker queue,\r\n   * or undefined if none are available within the timeout period.\r\n   */\r\n  private async getAWorker(flowId: string): Promise<Pool | undefined> {\r\n    logger.log(\r\n      Level.debug,\r\n      `${flowId} - ESHandler: Getting a worker from the queue...`,\r\n    );\r\n    const timeoutMs = this._getWorkerTimeoutMs;\r\n    const startTime = new Date().getTime();\r\n\r\n    const tryGetWorker = (): Promise<Pool | undefined> => {\r\n      return new Promise((resolve) => {\r\n        const tryNext = () => {\r\n          const worker = this._workersQueue.pop();\r\n          if (worker) {\r\n            resolve(worker);\r\n          } else if (new Date().getTime() - startTime >= timeoutMs) {\r\n            logger.log(\r\n              Level.debug,\r\n              `${flowId} - ESHandler: Timeout reached - no available worker found`,\r\n            );\r\n            resolve(undefined);\r\n          } else {\r\n            setTimeout(tryNext, 100);\r\n          }\r\n        };\r\n\r\n        tryNext();\r\n      });\r\n    };\r\n\r\n    return await tryGetWorker();\r\n  }\r\n\r\n  /**\r\n   * Adds a new worker pool to the worker queue.\r\n   * @param flowId - flowId for logging purposes\r\n   * @param client - The SuiClient instance to use it for the execution of transactions by the new worker pool.\r\n   * @param splitStrategy - (Optional) The SplitStrategy to use for splitting the main pool and creating the new pool.\r\n   */\r\n  private async addWorker(\r\n    flowId: string,\r\n    client: SuiClient,\r\n    splitStrategy?: SplitStrategy,\r\n  ) {\r\n    logger.log(\r\n      Level.debug,\r\n      `${flowId} - ESHandler: Adding new worker to the queue...`,\r\n    );\r\n    const newPool = await this._mainPool.split(client, splitStrategy);\r\n    logger.log(\r\n      Level.debug,\r\n      `${flowId} - ESHandler: New worker added to the queue: ${\r\n        newPool.id\r\n      } - ${Array.from(newPool.objects.keys())}`,\r\n    );\r\n    this._workersQueue.push(newPool);\r\n  }\r\n\r\n  /**\r\n   * Passes the given function to the access queue to ensure thread safety of mainPool.\r\n   * @param fn - The function to pass to the access queue.e.g., this._mainPool.addWorker(...)\r\n   * @private\r\n   */\r\n  private async passToAccessQueue(fn: () => Promise<void>) {\r\n    this._accessQueue = this._accessQueue.then(fn);\r\n    await this._accessQueue;\r\n  }\r\n}\r\n","// Copyright (c) Mysten Labs, Inc.\r\n// SPDX-License-Identifier: Apache-2.0\r\nimport type { TransactionBlock } from '@mysten/sui.js/transactions';\r\n\r\nexport type TransactionBlockLambda = (...args: any[]) => TransactionBlock;\r\n\r\n/**\r\n * A class that represents a transaction block with a lambda function.\r\n *\r\n * This is a wrapper class that allows you to pass the transaction block\r\n * creation inside a worker pool. The owned `objectIds` of the objects\r\n * that are needed to be passed as arguments in the transaction block,\r\n * are filled automatically by the worker pool.\r\n *\r\n * e.g., you have a transaction block that needs to mint an NFT,\r\n * but you need to pass an `AdminCap` to do so.\r\n *\r\n * Using this class you can create the transaction block in the lambda function,\r\n * and use a placeholder for the `AdminCap` object.\r\n * You also need to provide to the `lambdaArgs` the type of the object,\r\n * so the worker pool finds the objectId of the owned object -in this case\r\n * the `AdminCap`- by looking up its contents and fetching it by the provided type.\r\n *\r\n * i.e.,\r\n * ```\r\n * lambda = (adminCap: string) => {\r\n *  const txb = new TransactionBlock();\r\n *  txb.mintNFT(\r\n *    txb.object(\r\n *      adminCap, // This is the placeholder for the AdminCap object.\r\n *    \"NFT\"\r\n *    );\r\n *  return txb;\r\n * }\r\n * ```\r\n * `lambdaArgs = [\"AdminCap\"]`\r\n */\r\nexport class TransactionBlockWithLambda {\r\n  public lambda: TransactionBlockLambda;\r\n  public lambdaArgs?: any[] = [];\r\n\r\n  /**\r\n   * Initializes a TransactionBlockWithLambda instance.\r\n   * @param lambda The lambda function used to create a transaction block.\r\n   * @param lambdaArgs The lambda function arguments.\r\n   * Use this if you need to pass owned objects as arguments to your transaction\r\n   * block.\r\n   */\r\n  constructor(lambda: TransactionBlockLambda, lambdaArgs: any[] = []) {\r\n    this.lambda = lambda;\r\n    this.lambdaArgs = lambdaArgs;\r\n  }\r\n}\r\n"],"mappings":"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","names":["Level","dotenv","path","crypto"]}