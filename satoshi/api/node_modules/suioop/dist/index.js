"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DefaultSplitStrategy: () => DefaultSplitStrategy,
  ExecutorServiceHandler: () => ExecutorServiceHandler,
  IncludeAdminCapStrategy: () => IncludeAdminCapStrategy,
  Level: () => Level,
  Pool: () => Pool,
  TransactionBlockWithLambda: () => TransactionBlockWithLambda,
  isCoin: () => isCoin,
  isImmutable: () => isImmutable
});
module.exports = __toCommonJS(src_exports);

// src/logger.ts
var import_dotenv = __toESM(require("dotenv"));
var import_path = __toESM(require("path"));
var import_pino = require("pino");
var Level = /* @__PURE__ */ ((Level2) => {
  Level2["fatal"] = "fatal";
  Level2["error"] = "error";
  Level2["warn"] = "warn";
  Level2["info"] = "info";
  Level2["debug"] = "debug";
  Level2["trace"] = "trace";
  Level2["silent"] = "silent";
  return Level2;
})(Level || {});
var _Logger = class _Logger {
  constructor(level) {
    const pinoLogger = (0, import_pino.pino)(
      {
        base: null,
        level,
        timestamp: () => `,"time":"${(/* @__PURE__ */ new Date()).toISOString()}"`,
        pool_id: (id) => id,
        formatters: {
          level(label, number) {
            return { level: _Logger.levelsTranslator[number] };
          },
          log(object) {
            const { ...rest } = object;
            return rest;
          }
        },
        depthLimit: 10
      },
      process.stdout
    );
    this.logger = pinoLogger;
    _Logger.instance = this;
  }
  /**
   * Initialize the logger instance.
   * @param level {Level} - The minimum level to log.
   */
  static initialize(level = "error" /* error */) {
    if (!_Logger.instance) {
      new _Logger(level);
      return _Logger.instance;
    }
    return _Logger.instance;
  }
  /**
   * Wrapper method for the logging-library's log function.
   * @param level {Level} - The level to log at.
   * @param msg {string} - The message regarding the log.
   * @param pool_id {string} - The pool id to log; Used for tracing.
   */
  log(level = "info" /* info */, msg, pool_id) {
    _Logger.instance.logger[level]({ msg, pool_id });
  }
};
_Logger.levelsTranslator = {
  10: "trace",
  20: "debug",
  30: "info",
  40: "warn",
  50: "error",
  60: "fatal"
};
var Logger = _Logger;
import_dotenv.default.config({
  path: import_path.default.resolve(__dirname, "../test/.test.env")
});
var logger = Logger.initialize(process.env.LOGGING_LEVEL);

// src/pool.ts
var import_crypto = __toESM(require("crypto"));

// src/helpers.ts
async function isImmutable(objectId, client) {
  const obj = await client.getObject({
    id: objectId,
    options: {
      showOwner: true
    }
  });
  const objectOwner = obj?.data?.owner;
  if (!objectOwner) {
    throw new Error(`Could not extract "owner" field of object ${objectId}`);
  }
  return objectOwner == "Immutable";
}
function isCoin(objectType, ofType = "0x2::coin::Coin<0x2::sui::SUI>") {
  return objectType === ofType;
}

// src/splitStrategies.ts
var _DefaultSplitStrategy = class _DefaultSplitStrategy {
  constructor(minimumBalance = _DefaultSplitStrategy.defaultMinimumBalance) {
    this.balanceSoFar = 0;
    this.minimumBalance = minimumBalance;
  }
  pred(obj) {
    if (!obj)
      throw new Error("No object found!.");
    if (this.balanceSoFar >= this.minimumBalance) {
      return null;
    }
    if (isCoin(obj.type)) {
      this.balanceSoFar += obj.balance ?? 0;
      return true;
    } else {
      return false;
    }
  }
  succeeded() {
    return this.balanceSoFar >= this.minimumBalance;
  }
};
_DefaultSplitStrategy.defaultMinimumBalance = 4e8;
var DefaultSplitStrategy = _DefaultSplitStrategy;
var IncludeAdminCapStrategy = class {
  /**
   * Creates a new instance of the Pool class.
   * @param packageId - The ID of the package containing the AdminCap.
   * @param minimumBalance - The minimum balance of the pool
   * @param adminCapIdentifier - A name used to identify the AdminCap object.
   * (pool balance = sum of its' gas coin balances).
   */
  constructor(packageId, minimumBalance = DefaultSplitStrategy.defaultMinimumBalance, adminCapIdentifier = "AdminCap") {
    this.balanceSoFar = 0;
    this.adminCapIncluded = false;
    this.packageId = packageId;
    this.minimumBalance = minimumBalance;
    this.adminCapIdentifier = adminCapIdentifier;
  }
  pred(obj) {
    if (!obj)
      throw new Error("No object found!.");
    const terminateWhen = this.balanceSoFar >= this.minimumBalance && this.adminCapIncluded;
    if (terminateWhen) {
      return null;
    }
    if (!this.adminCapIncluded && obj.type.includes(this.adminCapIdentifier) && obj.type.includes(this.packageId)) {
      this.adminCapIncluded = true;
      return true;
    }
    if (!(this.balanceSoFar >= this.minimumBalance) && isCoin(obj.type)) {
      this.balanceSoFar += obj.balance ?? 0;
      return true;
    } else {
      return false;
    }
  }
  succeeded() {
    return this.balanceSoFar >= this.minimumBalance && this.adminCapIncluded;
  }
};

// src/pool.ts
var Pool = class _Pool {
  constructor(keypair, objects, gasCoins, client) {
    this._keypair = keypair;
    this._objects = objects;
    this._gasCoins = gasCoins;
    this._cursor = null;
    this._objectGenerator = this.objectBatchGenerator({
      owner: this._keypair.toSuiAddress(),
      client
    });
    this.id = _Pool.generateShortGUID();
  }
  static generateShortGUID() {
    const randomValue = import_crypto.default.randomBytes(8).toString("hex");
    const hash = import_crypto.default.createHash("md5").update(randomValue).digest("hex");
    return hash.slice(0, 8);
  }
  /**
   * Creates a new Pool instance and fetches an initial batch of objects.
   * The objects are fetched so that the pool is ready to be split.
   * @param input - An object containing the keypair and client to use.
   * @returns A Promise that resolves with the newly created Pool instance.
   */
  static async full(input) {
    const { keypair } = input;
    const pool = new _Pool(keypair, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), input.client);
    await pool.fetchObjects();
    return pool;
  }
  /**
   * Fetches a batch of objects from the object generator and adds them to the pool.
   * Also extracts any gas coins associated with the objects and adds them to the pool's gas coin collection.
   * @returns A boolean indicating whether the fetch was successful or not.
   */
  async fetchObjects() {
    const ownedObjectsBatch = await this._objectGenerator.next();
    if (!ownedObjectsBatch) {
      logger.log("error" /* error */, "Did not fetch any objects!", this.id);
      return false;
    }
    if (!ownedObjectsBatch.done && !ownedObjectsBatch.value) {
      logger.log("error" /* error */, "Did not fetch any objects!", this.id);
      return false;
    }
    if (ownedObjectsBatch.done) {
      logger.log(
        "warn" /* warn */,
        "End of cursor - No more objects to fetch!",
        this.id
      );
    }
    ownedObjectsBatch.value.forEach((value, key) => {
      this._objects.set(key, value);
    });
    _Pool.extractCoins(ownedObjectsBatch.value).forEach((value, key) => {
      this._gasCoins.set(key, value);
    });
    logger.log(
      "debug" /* debug */,
      `Fetched ${ownedObjectsBatch.value.size} objects.`,
      this.id
    );
    return true;
  }
  /**
   * Creates a generator that yields batches of objects owned by the pool's creator.
   * @generator
   * @async
   * @param {Object} input - An object containing the owner and client parameters.
   * @param {string} input.owner - The owner of the objects to retrieve.
   * @param {SuiClient} input.client - The SuiClient instance to use for retrieving the objects.
   * @yields {Map<string, ObjectReference>} A Map containing the object references for each batch of objects retrieved.
   * @throws {Error} If an object's data is undefined.
   */
  async *objectBatchGenerator(input) {
    let resp;
    let tempObjects;
    do {
      tempObjects = /* @__PURE__ */ new Map();
      resp = await input.client.getOwnedObjects({
        owner: input.owner,
        cursor: this._cursor,
        options: {
          showContent: true,
          showType: true
        }
      });
      resp.data.forEach((obj) => {
        if (!obj.data) {
          throw new Error(`Object data is undefined: ${obj.error}`);
        }
        let balance;
        const content = obj.data.content;
        if (typeof content === "object" && content !== null && "fields" in content && "type" in content) {
          const fields = content.fields;
          if ("balance" in fields) {
            balance = Number(fields.balance);
          }
        }
        const objectReference = {
          objectId: obj.data.objectId,
          digest: obj.data.digest,
          version: obj.data.version,
          type: obj.data.type ?? "",
          balance
        };
        if (objectReference) {
          tempObjects.set(objectReference.objectId, objectReference);
        }
      });
      yield tempObjects;
      this._cursor = resp?.nextCursor;
    } while (resp.hasNextPage);
  }
  /**
   * Lazily splits off a new Pool using the split strategy provided.
   * By lazy, we mean that the objects are fetched by the blockchain only when needed.
   * Initially, we try to split the pool using the objects that are already in the pool.
   * If the split strategy does not succeed/complete, then we fetch more objects and
   * try to split those as well. We repeat this process until the split strategy
   * succeeds, or we run out of objects to fetch.
   * @splitStrategy the strategy used to split the pool's objects and coins
   * @returns the new Pool with the objects and coins that were split off
   */
  async split(client, splitStrategy = new DefaultSplitStrategy()) {
    logger.log(
      "debug" /* debug */,
      `Splitting pool with ${this._objects.size} objects.`,
      this.id
    );
    let fetchSuccess;
    if (this._objects.size === 0) {
      fetchSuccess = await this.fetchObjects();
      if (!fetchSuccess) {
        throw new Error(
          `Pool (id: ${this.id}) split: Could not fetch any objects`
        );
      }
    }
    const objectsToGiveToNewPool = /* @__PURE__ */ new Map();
    const gasCoinsToGiveToNewPool = /* @__PURE__ */ new Map();
    do {
      this.splitObjects(splitStrategy).forEach((value, key) => {
        objectsToGiveToNewPool.set(key, value);
      });
      _Pool.extractCoins(objectsToGiveToNewPool).forEach((value, key) => {
        gasCoinsToGiveToNewPool.set(key, value);
      });
      if (splitStrategy.succeeded()) {
        break;
      }
      fetchSuccess = await this.fetchObjects();
    } while (!(splitStrategy.succeeded() || !fetchSuccess));
    if (!splitStrategy.succeeded()) {
      throw new Error(
        `Pool (id: ${this.id}) split: The split strategy did not succeed even having fetched all the objects.`
      );
    }
    const newPool = new _Pool(
      this._keypair,
      objectsToGiveToNewPool,
      gasCoinsToGiveToNewPool,
      client
    );
    if (newPool.objects.size === 0) {
      logger.log(
        "warn" /* warn */,
        `Pool (id: ${this.id}): Failed to split. newPool does not contain any objects.`
      );
    }
    if (newPool.gasCoins.size === 0) {
      logger.log(
        "warn" /* warn */,
        `Pool (id: ${this.id}): Failed to split. newPool does not contain any gas coins.`
      );
      throw new Error(
        `Pool (id: ${this.id}): Failed to split. newPool does not contain any gas coins.`
      );
    }
    logger.log(
      "info" /* info */,
      `Split completed: main pool (${this.id}) = ${this._objects.size} objects, new pool (${newPool.id}) = ${newPool._objects.size} objects`,
      this.id
    );
    _Pool.extractCoins(newPool.gasCoins).forEach((_value, key) => {
      this._gasCoins.delete(key);
    });
    return newPool;
  }
  /**
   * Splits off the pool's objects map into two new maps.
   * One for the current pool (the ones with the objects to keep),
   * and one for the new pool (the ones to give).
   * The split strategy determines in which map each object will be moved to.
   * @param splitStrategy determines which objects will be moved to the new pool.
   * @returns the map of objects that will be assigned to the new pool
   */
  splitObjects(splitStrategy) {
    const objects_to_keep = /* @__PURE__ */ new Map();
    const objects_to_give = /* @__PURE__ */ new Map();
    const objects_array = Array.from(this._objects, ([objectId, object]) => ({
      objectId,
      object
    }));
    outside:
      while (objects_array.length !== 0) {
        const last_object_in_array = objects_array.pop();
        if (last_object_in_array === void 0) {
          logger.log(
            "warn" /* warn */,
            "No more main pool objects. Terminating split.",
            this.id
          );
          break;
        }
        switch (splitStrategy.pred(last_object_in_array.object)) {
          case true: {
            objects_to_give.set(
              last_object_in_array.objectId,
              last_object_in_array.object
            );
            break;
          }
          case false: {
            const obj_keep = last_object_in_array;
            objects_to_keep.set(obj_keep.objectId, obj_keep.object);
            break;
          }
          case null: {
            objects_array.forEach((obj) => {
              objects_to_keep.set(obj.objectId, obj.object);
            });
            objects_to_keep.set(
              last_object_in_array.objectId,
              last_object_in_array.object
            );
            break outside;
          }
        }
      }
    this._objects = objects_to_keep;
    return objects_to_give;
  }
  /**
   * Merges the objects of poolToMerge to this pool.
   * @param poolToMerge The pool whose objects will be merged to this pool.
   */
  merge(poolToMerge) {
    logger.log(
      "debug" /* debug */,
      `Merging with pool ${poolToMerge.id} of ${poolToMerge._objects.size} objects. Current pool has ${this._objects.size} objects.`,
      this.id
    );
    poolToMerge.objects.forEach((value, key) => {
      this._objects.set(key, value);
    });
    poolToMerge.deleteObjects();
    logger.log(
      "debug" /* debug */,
      `Merge complete: pool ${this.id} now has ${this._objects.size} objects.`,
      this.id
    );
  }
  /**
   * Signs and executes a transaction block using the provided client and options.
   * @param input An object containing the client, transaction block, options, and request type.
   * @returns A promise that resolves to a SuiTransactionBlockResponse object.
   * @throws An error if any of the objects in the transaction block are not owned by the pool's creator,
   * or if there are no SUI coins in the pool to use as gas payment,
   * or if the dry run of the transaction block fails.
   */
  async signAndExecuteTransactionBlock(input) {
    logger.log(
      "debug" /* debug */,
      `Starting signAndExecuteTransactionBlock: current objects pool size: ${this._objects.size}`,
      this.id
    );
    let { transactionBlockLambda, options, requestType } = input;
    let transactionBlockComplete;
    if (transactionBlockLambda.lambdaArgs) {
      transactionBlockComplete = transactionBlockLambda.lambda(
        ...transactionBlockLambda.lambdaArgs.map((arg) => {
          return this.getObjectOfType(arg);
        })
      );
    } else {
      transactionBlockComplete = transactionBlockLambda.lambda();
    }
    logger.log("debug" /* debug */, "Checking object ownership...", this.id);
    transactionBlockComplete.setSender(
      this.keypair.getPublicKey().toSuiAddress()
    );
    if (!await this.checkTotalOwnership(transactionBlockComplete, input.client)) {
      throw new Error(
        "All objects of the transaction block must be owned by the pool's creator."
      );
    }
    const coinsArray = Array.from(this._gasCoins.values());
    const NoSuiCoinFound = coinsArray.length === 0;
    logger.log(
      "debug" /* debug */,
      `Coins used as gas payment: ${JSON.stringify(coinsArray)}`,
      this.id
    );
    if (NoSuiCoinFound) {
      throw new Error("No SUI coins in the pool to use as gas payment.");
    }
    transactionBlockComplete.setGasPayment(coinsArray);
    logger.log("debug" /* debug */, "Dry running the transaction block...", this.id);
    const dryRunRes = await input.client.dryRunTransactionBlock({
      transactionBlock: await transactionBlockComplete.build({
        client: input.client
      })
    });
    if (dryRunRes.effects.status.status !== "success") {
      throw new Error(`Dry run failed. ${dryRunRes.effects.status.error}`);
    }
    const res = await input.client.signAndExecuteTransactionBlock({
      transactionBlock: transactionBlockComplete,
      requestType,
      options: {
        ...options,
        showEffects: true,
        showObjectChanges: true
      },
      signer: this._keypair
    });
    const created = res.effects?.created;
    const unwrapped = res.effects?.unwrapped;
    const mutated = res.effects?.mutated;
    const wrapped = res.effects?.wrapped;
    const deleted = res.effects?.deleted;
    logger.log(
      "debug" /* debug */,
      `Transaction block executed. Created: ${JSON.stringify(
        created
      )}, Unwrapped: ${JSON.stringify(unwrapped)}, Mutated: ${JSON.stringify(
        mutated
      )}, Wrapped: ${JSON.stringify(wrapped)}, Deleted: ${JSON.stringify(
        deleted
      )}`,
      this.id
    );
    logger.log("debug" /* debug */, "Updating pool...", this.id);
    this.updatePool(created);
    this.updatePool(unwrapped);
    this.updatePool(mutated);
    this.removeFromPool(wrapped);
    this.removeFromPool(deleted);
    if (mutated) {
      await this.updateCoins(mutated, input.client);
    }
    logger.log(
      "debug" /* debug */,
      `Pool updated. Current pool has ${this._objects.size} objects.`,
      this.id
    );
    return res;
  }
  /**
   * After the transaction block execution, updates the pool with new references,
   * if the owner of the reference is the same as the signer address.
   * @param newRefs An array of OwnedObjectRef objects representing the new references to add to the pool.
   */
  updatePool(newRefs) {
    const signerAddress = this._keypair.getPublicKey().toSuiAddress();
    if (!newRefs)
      return;
    for (const ref in newRefs) {
      const objectOwner = newRefs[ref].owner.AddressOwner;
      const object = newRefs[ref].reference;
      const objectId = object.objectId;
      if (objectOwner != signerAddress) {
        return;
      }
      const toUpdate = {
        ...object,
        type: this._objects.get(objectId)?.type ?? ""
      };
      this._objects.set(objectId, toUpdate);
    }
  }
  /**
   * Removes the given object references from the pool.
   * Called after a transaction block execution for wrapped or deleted objects.
   * @param newRefs - The object references to remove from the pool.
   */
  removeFromPool(newRefs) {
    if (!newRefs)
      return;
    for (const ref of newRefs) {
      const objectId = ref.objectId;
      this._objects.delete(objectId);
    }
  }
  async updateCoins(mutated, client) {
    const mutatedCoinsObjectIds = mutated.filter((mutatedCoin) => {
      return this._gasCoins.has(mutatedCoin.reference.objectId);
    }).map((mutatedCoin) => {
      return mutatedCoin.reference.objectId;
    });
    const mutatedCoinsOnChainContents = await client.multiGetObjects({
      ids: mutatedCoinsObjectIds,
      options: { showContent: true }
    });
    mutatedCoinsOnChainContents.forEach((mutatedCoinObject) => {
      if ("data" in mutatedCoinObject && "content" in mutatedCoinObject.data && "fields" in mutatedCoinObject.data.content && "balance" in mutatedCoinObject.data.content.fields) {
        const objectId = mutatedCoinObject.data.objectId;
        const balance = Number(mutatedCoinObject.data.content.fields.balance);
        const coin = this._gasCoins.get(objectId);
        if (!coin) {
          const err = `Coin ${objectId} not found in the pool.`;
          logger.log("error" /* error */, err);
          throw new Error(err);
        }
        coin.balance = balance;
        coin.version = mutatedCoinObject.data.version;
        coin.digest = mutatedCoinObject.data.digest;
        this._gasCoins.set(coin.objectId, coin);
      }
    });
  }
  /**
   * Checks if all inputs in the transaction block are owned by the pool's creator or are immutable.
   * @param txb - The transaction block to check.
   * @param client - The SuiClient instance to use for checking immutability.
   * @returns A Promise that resolves to a boolean indicating whether all inputs are owned by the pool's creator or are immutable.
   */
  async checkTotalOwnership(txb, client) {
    await txb.build({ client });
    const ownedInputs = txb.blockData.inputs.filter((input) => {
      return input.type === "object" && ("Object" in input.value || "Input" in input.value) && "ImmOrOwned" in input.value.Object;
    });
    return ownedInputs.every(async (ownedInput) => {
      const objID = ownedInput.value.Object.ImmOrOwned.objectId;
      const isInsidePool = this.isInsidePool(objID);
      const notInsidePool = !isInsidePool;
      if (notInsidePool) {
        const immutable = await isImmutable(objID, client);
        if (immutable) {
          return true;
        } else {
          console.error(`Object ${objID} is not owned by the pool's creator.`);
        }
      }
      return isInsidePool;
    });
  }
  /**
   * Check if the id of an object is in the object pool.
   * @param id the object id to check
   * @returns true if the object is in the pool, false otherwise
   */
  isInsidePool(id) {
    return this._objects.has(id);
  }
  get objects() {
    return this._objects;
  }
  get gasCoins() {
    return this._gasCoins;
  }
  deleteObjects() {
    this._objects.clear();
  }
  /**
   * Filters all the coins from pool's objects.
   * @param fromObjects - The pool of objects to extract coins from.
   * @returns A new pool of objects containing only the coins.
   * @throws An error if there are no coins in the pool.
   */
  static extractCoins(fromObjects) {
    const coinsMap = /* @__PURE__ */ new Map();
    for (const [key, value] of fromObjects) {
      if (isCoin(value.type)) {
        coinsMap.set(key, value);
      }
    }
    if (!coinsMap) {
      throw new Error("No gas coins in the pool.");
    }
    return coinsMap;
  }
  /**
   * Looks up the pool for an object of the given type
   * and returns its object id.
   * @param type
   * @private
   */
  getObjectOfType(type) {
    const objectEntry = Array.from(this._objects.entries()).find(
      ([key, value]) => {
        if (value.type.includes(type)) {
          return key;
        }
      }
    );
    const objectId = objectEntry?.[0];
    if (!objectId) {
      throw new Error(`No ${type} found in the pool.`);
    }
    return objectId;
  }
  get keypair() {
    return this._keypair;
  }
  set keypair(value) {
    this._keypair = value;
  }
};

// src/executorServiceHandler.ts
var ExecutorServiceHandler = class _ExecutorServiceHandler {
  constructor(mainPool, getWorkerTimeoutMs) {
    // shared resource between threads
    this._workersQueue = [];
    // shared resource between threads
    this._accessQueue = Promise.resolve();
    this._mainPool = mainPool;
    this._getWorkerTimeoutMs = getWorkerTimeoutMs;
  }
  /**
   * Initializes an ExecutorServiceHandler instance.
   * @param keypair - The keypair to use for authentication.
   * @param client - The SuiClient instance to use for communication with the Sui network.
   * @param getWorkerTimeoutMs - The maximum number of milliseconds to listen for an available
   * worker from the worker queue.
   * @returns A new ExecutorServiceHandler instance.
   */
  static async initialize(keypair, client, getWorkerTimeoutMs = 1e4) {
    const pool = await Pool.full({ keypair, client });
    return new _ExecutorServiceHandler(pool, getWorkerTimeoutMs);
  }
  /**
   * Executes the given transaction block using the provided SuiClient and split strategy (if any).
   * Retries the execution up to the specified number of times in case of errors.
   *
   * Note that the execution is asynchronous and the result is returned as a Promise.
   * This means that you can execute multiple transaction blocks in parallel **without**
   * equivocating objects, as long as the splitStrategy permits it.
   * @param txb The transaction block to execute.
   * @param client The SuiClient instance is to use it for execution.
   * @param splitStrategy The SplitStrategy used to determine how a new worker pool will be split
   * from the main pool in case a new worker is needed to execute the transaction.
   * @param options (Optional) The SuiTransactionBlockResponseOptions to use for executing the transaction block.
   * @param requestType (Optional) The ExecuteTransactionRequestType to use for executing the transaction block.
   * @param retries The maximum number of retries in case of errors (default: 3).
   * @returns A Promise that resolves to the result of the transaction block execution.
   * @throws An error if all retries fail.
   */
  async execute(txb, client, splitStrategy, options, requestType, retries = 3) {
    let res;
    const flowId = Pool.generateShortGUID();
    do {
      try {
        res = await this.executeFlow(
          flowId,
          txb,
          client,
          splitStrategy,
          options,
          requestType
        );
      } catch (e) {
        logger.log(
          "error" /* error */,
          `${flowId} - ESHandler: Error executing transaction block: ${e} - ${retries - 1} retries left...`
        );
        continue;
      }
      if (res) {
        logger.log(
          "info" /* info */,
          `${flowId} - ESHandler: Transaction block execution completed - digest: ${JSON.stringify(
            res.digest
          )}`
        );
        return res;
      }
      logger.log(
        "debug" /* debug */,
        `${flowId} - ESHandler: Could not execute flow: unavailable worker - ${retries - 1} retries left...`
      );
    } while (--retries > 0);
    logger.log(
      "error" /* error */,
      `${flowId} - ESHandler: executeFlowError - All retries failed: Could not execute the transaction block`
    );
    throw new Error(
      `${flowId} - ESHandler: executeFlowError - All retries failed: Could not execute the transaction block`
    );
  }
  /**
   * Helper function of execute(). Contains the main logic for executing a transaction block,
   * including getting an available worker from the workers array, updating the workerPool status, etc.
   * @param flowId - flowId for logging purposes
   * @param txb The transaction block to execute.
   * @param client The SuiClient to use for executing the transaction block.
   * @param options (Optional) The SuiTransactionBlockResponseOptions to use for executing the transaction block.
   * @param requestType (Optional) The ExecuteTransactionRequestType to use for executing the transaction block.
   * @param splitStrategy (Optional) The SplitStrategy to use for splitting the main pool and getting a new worker pool.
   * @returns A Promise that resolves to the SuiTransactionBlockResponse object returned by executing the transaction block.
   */
  async executeFlow(flowId, txb, client, splitStrategy, options, requestType) {
    let worker;
    try {
      worker = await this.getAWorker(flowId);
    } catch (e) {
      worker = void 0;
    }
    const noWorkerAvailable = worker === void 0;
    if (noWorkerAvailable) {
      logger.log(
        "debug" /* debug */,
        `${flowId} - ESHandler: Could not find an available worker.`
      );
      await this.passToAccessQueue(async () => {
        await this.addWorker(flowId, client, splitStrategy);
      });
      return;
    } else if (worker) {
      logger.log(
        "debug" /* debug */,
        `${flowId} - ESHandler: Found an available worker: ${worker.id}. Executing transaction block...`
      );
      let result;
      try {
        result = await worker.signAndExecuteTransactionBlock({
          transactionBlockLambda: txb,
          client,
          options,
          requestType
        });
      } catch (e) {
        logger.log(
          "warn" /* warn */,
          `${flowId} - ESHandler: Error executing transaction block: ${e}`
        );
        await this.passToAccessQueue(async () => {
          if (worker) {
            this._mainPool.merge(worker);
          }
        });
        return;
      }
      if (result.effects && result.effects.status.status === "failure") {
        logger.log(
          "error" /* error */,
          `${flowId} - ESHandler: Error executing transaction block: result status is "failure"`
        );
        await this.passToAccessQueue(async () => {
          if (worker) {
            this._mainPool.merge(worker);
          }
        });
        return;
      }
      logger.log(
        "debug" /* debug */,
        `${flowId} - ESHandler: Transaction block execution completed! Pushing worker ${worker.id} back to the queue...`
      );
      this._workersQueue.push(worker);
      return result;
    }
  }
  /**
   * Returns an available worker from the worker queue, or undefined if none are available within the timeout period.
   * @returns {Pool | undefined} - An available worker from the worker queue,
   * or undefined if none are available within the timeout period.
   */
  async getAWorker(flowId) {
    logger.log(
      "debug" /* debug */,
      `${flowId} - ESHandler: Getting a worker from the queue...`
    );
    const timeoutMs = this._getWorkerTimeoutMs;
    const startTime = (/* @__PURE__ */ new Date()).getTime();
    const tryGetWorker = () => {
      return new Promise((resolve) => {
        const tryNext = () => {
          const worker = this._workersQueue.pop();
          if (worker) {
            resolve(worker);
          } else if ((/* @__PURE__ */ new Date()).getTime() - startTime >= timeoutMs) {
            logger.log(
              "debug" /* debug */,
              `${flowId} - ESHandler: Timeout reached - no available worker found`
            );
            resolve(void 0);
          } else {
            setTimeout(tryNext, 100);
          }
        };
        tryNext();
      });
    };
    return await tryGetWorker();
  }
  /**
   * Adds a new worker pool to the worker queue.
   * @param flowId - flowId for logging purposes
   * @param client - The SuiClient instance to use it for the execution of transactions by the new worker pool.
   * @param splitStrategy - (Optional) The SplitStrategy to use for splitting the main pool and creating the new pool.
   */
  async addWorker(flowId, client, splitStrategy) {
    logger.log(
      "debug" /* debug */,
      `${flowId} - ESHandler: Adding new worker to the queue...`
    );
    const newPool = await this._mainPool.split(client, splitStrategy);
    logger.log(
      "debug" /* debug */,
      `${flowId} - ESHandler: New worker added to the queue: ${newPool.id} - ${Array.from(newPool.objects.keys())}`
    );
    this._workersQueue.push(newPool);
  }
  /**
   * Passes the given function to the access queue to ensure thread safety of mainPool.
   * @param fn - The function to pass to the access queue.e.g., this._mainPool.addWorker(...)
   * @private
   */
  async passToAccessQueue(fn) {
    this._accessQueue = this._accessQueue.then(fn);
    await this._accessQueue;
  }
};

// src/transactions.ts
var TransactionBlockWithLambda = class {
  /**
   * Initializes a TransactionBlockWithLambda instance.
   * @param lambda The lambda function used to create a transaction block.
   * @param lambdaArgs The lambda function arguments.
   * Use this if you need to pass owned objects as arguments to your transaction
   * block.
   */
  constructor(lambda, lambdaArgs = []) {
    this.lambdaArgs = [];
    this.lambda = lambda;
    this.lambdaArgs = lambdaArgs;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DefaultSplitStrategy,
  ExecutorServiceHandler,
  IncludeAdminCapStrategy,
  Level,
  Pool,
  TransactionBlockWithLambda,
  isCoin,
  isImmutable
});
//# sourceMappingURL=index.js.map