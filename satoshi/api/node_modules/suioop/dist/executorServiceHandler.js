"use strict";
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutorServiceHandler = void 0;
const logger_1 = require("./logger");
const pool_1 = require("./pool");
/**
 * A class that orchestrates the execution of transaction blocks using multiple worker pools.
 * The workers are created by splitting a main pool and are used to execute transaction blocks asynchronously without object equivocation.
 * [Note: ] The mainPool is not a worker pool and is not used for transaction block execution. It is used only for splitting.
 * The number of workers is not fixed and can be increased by splitting the main pool if the workload requires it.
 * The ExecutorServiceHandler retries the execution of the transaction block up to a specified number of times in case of errors.
 */
class ExecutorServiceHandler {
    constructor(mainPool, getWorkerTimeoutMs) {
        this._workersQueue = []; // shared resource between threads
        this._accessQueue = Promise.resolve(); // mutex for thread safety of mainPool access
        this._mainPool = mainPool;
        this._getWorkerTimeoutMs = getWorkerTimeoutMs;
    }
    /**
     * Initializes an ExecutorServiceHandler instance.
     * @param keypair - The keypair to use for authentication.
     * @param client - The SuiClient instance to use for communication with the Sui network.
     * @param getWorkerTimeoutMs - The maximum number of milliseconds to listen for an available
     * worker from the worker queue.
     * @returns A new ExecutorServiceHandler instance.
     */
    static async initialize(keypair, client, getWorkerTimeoutMs = 10000) {
        const pool = await pool_1.Pool.full({ keypair: keypair, client });
        return new ExecutorServiceHandler(pool, getWorkerTimeoutMs);
    }
    /**
     * Executes the given transaction block using the provided SuiClient and split strategy (if any).
     * Retries the execution up to the specified number of times in case of errors.
     *
     * Note that the execution is asynchronous and the result is returned as a Promise.
     * This means that you can execute multiple transaction blocks in parallel **without**
     * equivocating objects, as long as the splitStrategy permits it.
     * @param txb The transaction block to execute.
     * @param client The SuiClient instance is to use it for execution.
     * @param splitStrategy The SplitStrategy used to determine how a new worker pool will be split
     * from the main pool in case a new worker is needed to execute the transaction.
     * @param options (Optional) The SuiTransactionBlockResponseOptions to use for executing the transaction block.
     * @param requestType (Optional) The ExecuteTransactionRequestType to use for executing the transaction block.
     * @param retries The maximum number of retries in case of errors (default: 3).
     * @returns A Promise that resolves to the result of the transaction block execution.
     * @throws An error if all retries fail.
     */
    async execute(txb, client, splitStrategy, options, requestType, retries = 3) {
        let res;
        const flowId = pool_1.Pool.generateShortGUID();
        do {
            try {
                res = await this.executeFlow(flowId, txb, client, splitStrategy, options, requestType);
            }
            catch (e) {
                logger_1.logger.log(logger_1.Level.error, `${flowId} - ESHandler: Error executing transaction block: ${e} - ${retries - 1} retries left...`);
                continue;
            }
            if (res) {
                logger_1.logger.log(logger_1.Level.info, `${flowId} - ESHandler: Transaction block execution completed - digest: ${JSON.stringify(res.digest)}`);
                return res;
            }
            logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: Could not execute flow: unavailable worker - ${retries - 1} retries left...`);
        } while (--retries > 0);
        logger_1.logger.log(logger_1.Level.error, `${flowId} - ESHandler: executeFlowError - All retries failed: Could not execute the transaction block`);
        throw new Error(`${flowId} - ESHandler: executeFlowError - All retries failed: Could not execute the transaction block`);
    }
    /**
     * Helper function of execute(). Contains the main logic for executing a transaction block,
     * including getting an available worker from the workers array, updating the workerPool status, etc.
     * @param flowId - flowId for logging purposes
     * @param txb The transaction block to execute.
     * @param client The SuiClient to use for executing the transaction block.
     * @param options (Optional) The SuiTransactionBlockResponseOptions to use for executing the transaction block.
     * @param requestType (Optional) The ExecuteTransactionRequestType to use for executing the transaction block.
     * @param splitStrategy (Optional) The SplitStrategy to use for splitting the main pool and getting a new worker pool.
     * @returns A Promise that resolves to the SuiTransactionBlockResponse object returned by executing the transaction block.
     */
    async executeFlow(flowId, txb, client, splitStrategy, options, requestType) {
        let worker;
        try {
            worker = await this.getAWorker(flowId);
        }
        catch (e) {
            worker = undefined;
        }
        const noWorkerAvailable = worker === undefined;
        if (noWorkerAvailable) {
            logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: Could not find an available worker.`);
            await this.passToAccessQueue(async () => {
                await this.addWorker(flowId, client, splitStrategy);
            });
            return;
        }
        else if (worker) {
            logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: Found an available worker: ${worker.id}. Executing transaction block...`);
            let result;
            try {
                result = await worker.signAndExecuteTransactionBlock({
                    transactionBlockLambda: txb,
                    client: client,
                    options,
                    requestType,
                });
            }
            catch (e) {
                logger_1.logger.log(logger_1.Level.warn, `${flowId} - ESHandler: Error executing transaction block: ${e}`);
                await this.passToAccessQueue(async () => {
                    if (worker) {
                        this._mainPool.merge(worker);
                    }
                });
                return;
            }
            if (result.effects && result.effects.status.status === 'failure') {
                logger_1.logger.log(logger_1.Level.error, `${flowId} - ESHandler: Error executing transaction block: result status is "failure"`);
                await this.passToAccessQueue(async () => {
                    if (worker) {
                        this._mainPool.merge(worker);
                    }
                });
                return;
            }
            logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: Transaction block execution completed! Pushing worker ${worker.id} back to the queue...`);
            // Execution finished, the worker is now available again.
            this._workersQueue.push(worker);
            return result;
        }
    }
    /**
     * Returns an available worker from the worker queue, or undefined if none are available within the timeout period.
     * @returns {Pool | undefined} - An available worker from the worker queue,
     * or undefined if none are available within the timeout period.
     */
    async getAWorker(flowId) {
        logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: Getting a worker from the queue...`);
        const timeoutMs = this._getWorkerTimeoutMs;
        const startTime = new Date().getTime();
        const tryGetWorker = () => {
            return new Promise((resolve) => {
                const tryNext = () => {
                    const worker = this._workersQueue.pop();
                    if (worker) {
                        resolve(worker);
                    }
                    else if (new Date().getTime() - startTime >= timeoutMs) {
                        logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: Timeout reached - no available worker found`);
                        resolve(undefined);
                    }
                    else {
                        setTimeout(tryNext, 100);
                    }
                };
                tryNext();
            });
        };
        return await tryGetWorker();
    }
    /**
     * Adds a new worker pool to the worker queue.
     * @param flowId - flowId for logging purposes
     * @param client - The SuiClient instance to use it for the execution of transactions by the new worker pool.
     * @param splitStrategy - (Optional) The SplitStrategy to use for splitting the main pool and creating the new pool.
     */
    async addWorker(flowId, client, splitStrategy) {
        logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: Adding new worker to the queue...`);
        const newPool = await this._mainPool.split(client, splitStrategy);
        logger_1.logger.log(logger_1.Level.debug, `${flowId} - ESHandler: New worker added to the queue: ${newPool.id} - ${Array.from(newPool.objects.keys())}`);
        this._workersQueue.push(newPool);
    }
    /**
     * Passes the given function to the access queue to ensure thread safety of mainPool.
     * @param fn - The function to pass to the access queue.e.g., this._mainPool.addWorker(...)
     * @private
     */
    async passToAccessQueue(fn) {
        this._accessQueue = this._accessQueue.then(fn);
        await this._accessQueue;
    }
}
exports.ExecutorServiceHandler = ExecutorServiceHandler;
//# sourceMappingURL=executorServiceHandler.js.map