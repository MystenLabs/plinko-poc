{"version":3,"sources":["../src/index.ts","../src/b64.ts","../src/hex.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n * BCS implementation {@see https://github.com/diem/bcs } for JavaScript.\n * Intended to be used for Move applications; supports both NodeJS and browser.\n *\n * For more details and examples {@see README.md }.\n *\n * @module bcs\n * @property {BcsReader}\n */\n\nimport { toB64, fromB64 } from \"./b64\";\nimport { toHEX, fromHEX } from \"./hex\";\nimport bs58 from \"bs58\";\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\n\nconst toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nconst fromB58 = (str: string) => bs58.decode(str);\n\n// Re-export all encoding dependencies.\nexport { toB58, fromB58, toB64, fromB64, fromHEX, toHEX };\n\n/**\n * Supported encodings.\n * Used in `Reader.toString()` as well as in `decodeStr` and `encodeStr` functions.\n */\nexport type Encoding = \"base58\" | \"base64\" | \"hex\";\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n  private dataView: DataView;\n  private bytePosition: number = 0;\n\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data: Uint8Array) {\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes: number) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8(): number {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16(): number {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32(): number {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64(): string {\n    let value1 = this.read32();\n    let value2 = this.read32();\n\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128(): string {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256(): string {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num: number): Uint8Array {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n\n    this.shift(num);\n\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB(): number {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let { value, length } = ulebDecode(buffer);\n\n    this.shift(length);\n\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\ninterface BcsWriterOptions {\n  /** The initial size (in bytes) of the buffer tht will be allocated */\n  size?: number;\n  /** The maximum size (in bytes) that the buffer is allowed to grow to */\n  maxSize?: number;\n  /** The amount of bytes that will be allocated whenever additional memory is required */\n  allocateSize?: number;\n}\n\nexport class BcsWriter {\n  private dataView: DataView;\n  private bytePosition: number = 0;\n  private size: number;\n  private maxSize: number;\n  private allocateSize: number;\n\n  constructor({\n    size = 1024,\n    maxSize,\n    allocateSize = 1024,\n  }: BcsWriterOptions = {}) {\n    this.size = size;\n    this.maxSize = maxSize || size;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(size));\n  }\n\n  private ensureSizeOrGrow(bytes: number) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(\n          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`\n        );\n      }\n\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes: number): this {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value: number | bigint): this {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value: number | bigint): this {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value: number | bigint): this {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value: number | bigint): this {\n    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value: number | bigint): this {\n    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value: number | bigint): this {\n    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value: number): this {\n    ulebEncode(value).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(\n    vector: any[],\n    cb: (writer: BcsWriter, el: any, i: number, len: number) => {}\n  ): this {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes(): Uint8Array {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding: Encoding): string {\n    return encodeStr(this.toBytes(), encoding);\n  }\n}\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nfunction ulebEncode(num: number): number[] {\n  let arr = [];\n  let len = 0;\n\n  if (num === 0) {\n    return [0];\n  }\n\n  while (num > 0) {\n    arr[len] = num & 0x7f;\n    if ((num >>= 7)) {\n      arr[len] |= 0x80;\n    }\n    len += 1;\n  }\n\n  return arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nfunction ulebDecode(arr: number[] | Uint8Array): {\n  value: number;\n  length: number;\n} {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 0x7f) << shift;\n    if ((byte & 0x80) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n\n  return {\n    value: total,\n    length: len,\n  };\n}\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport interface TypeInterface {\n  encode: (\n    self: BCS,\n    data: any,\n    options: BcsWriterOptions | undefined,\n    typeParams: TypeName[]\n  ) => BcsWriter;\n  decode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n  _encodeRaw: (\n    writer: BcsWriter,\n    data: any,\n    typeParams: TypeName[],\n    typeMap: { [key: string]: TypeName }\n  ) => BcsWriter;\n  _decodeRaw: (\n    reader: BcsReader,\n    typeParams: TypeName[],\n    typeMap: { [key: string]: TypeName }\n  ) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n  [key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n  [key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n  /**\n   * Defines type name for the vector / array type.\n   * In Move: `vector<T>` or `vector`.\n   */\n  vectorType: string;\n  /**\n   * Address length. Varies depending on a platform and\n   * has to be specified for the `address` type.\n   */\n  addressLength: number;\n\n  /**\n   * Custom encoding for address. Supported values are\n   * either 'hex' or 'base64'.\n   */\n  addressEncoding?: \"hex\" | \"base64\";\n  /**\n   * Opening and closing symbol for type parameters. Can be\n   * any pair of symbols (eg `['(', ')']`); default value follows\n   * Rust and Move: `<` and `>`.\n   */\n  genericSeparators?: [string, string];\n  /**\n   * Type definitions for the BCS. This field allows spawning\n   * BCS instance from JSON or another prepared configuration.\n   * Optional.\n   */\n  types?: {\n    structs?: { [key: string]: StructTypeDefinition };\n    enums?: { [key: string]: EnumTypeDefinition };\n    aliases?: { [key: string]: string };\n  };\n  /**\n   * Whether to auto-register primitive types on launch.\n   */\n  withPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n  // Prefefined types constants\n  static readonly U8: string = \"u8\";\n  static readonly U16: string = \"u16\";\n  static readonly U32: string = \"u32\";\n  static readonly U64: string = \"u64\";\n  static readonly U128: string = \"u128\";\n  static readonly U256: string = \"u256\";\n  static readonly BOOL: string = \"bool\";\n  static readonly VECTOR: string = \"vector\";\n  static readonly ADDRESS: string = \"address\";\n  static readonly STRING: string = \"string\";\n  static readonly HEX: string = \"hex-string\";\n  static readonly BASE58: string = \"base58-string\";\n  static readonly BASE64: string = \"base64-string\";\n\n  /**\n   * Map of kind `TypeName => TypeInterface`. Holds all\n   * callbacks for (de)serialization of every registered type.\n   *\n   * If the value stored is a string, it is treated as an alias.\n   */\n  public types: Map<string, TypeInterface | string> = new Map();\n\n  /**\n   * Stored BcsConfig for the current instance of BCS.\n   */\n  protected schema: BcsConfig;\n\n  /**\n   * Count temp keys to generate a new one when requested.\n   */\n  protected counter: number = 0;\n\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  private tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema: BcsConfig | BCS) {\n    // if BCS instance is passed -> clone its schema\n    if (schema instanceof BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n\n    this.schema = schema;\n\n    // Register address type under key 'address'.\n    this.registerAddressType(\n      BCS.ADDRESS,\n      schema.addressLength,\n      schema.addressEncoding\n    );\n    this.registerVectorType(schema.vectorType);\n\n    // Register struct types if they were passed.\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n\n    // Register enum types if they were passed.\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n\n    // Register aliases if they were passed.\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  public ser(\n    type: TypeName | StructTypeDefinition,\n    data: any,\n    options?: BcsWriterOptions\n  ): BcsWriter {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(\n        this,\n        data,\n        options,\n        params as string[]\n      );\n    }\n\n    // Quick serialization without registering the type in the main struct.\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n\n    throw new Error(\n      `Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(\n        type\n      )}`\n    );\n  }\n\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  public de(\n    type: TypeName | StructTypeDefinition,\n    data: Uint8Array | string,\n    encoding?: Encoding\n  ): any {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n\n    // In case the type specified is already registered.\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params as string[]);\n    }\n\n    // Deserialize without registering a type using a temporary clone.\n    if (typeof type === \"object\") {\n      const temp = new BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n\n    throw new Error(\n      `Incorrect type passed into the '.de()' function. \\n${JSON.stringify(\n        type\n      )}`\n    );\n  }\n\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  public hasType(type: string): boolean {\n    return this.types.has(type);\n  }\n\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  public registerAlias(name: string, forType: string): BCS {\n    this.types.set(name, forType);\n    return this;\n  }\n\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  public registerType(\n    typeName: TypeName,\n    encodeCb: (\n      writer: BcsWriter,\n      data: any,\n      typeParams: TypeName[],\n      typeMap: { [key: string]: TypeName }\n    ) => BcsWriter,\n    decodeCb: (\n      reader: BcsReader,\n      typeParams: TypeName[],\n      typeMap: { [key: string]: TypeName }\n    ) => any,\n    validateCb: (data: any) => boolean = () => true\n  ): BCS {\n    const { name, params: generics } = this.parseTypeName(typeName);\n\n    this.types.set(name, {\n      encode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n        const typeMap = (generics as string[]).reduce(\n          (acc: any, value: string, index) => {\n            return Object.assign(acc, { [value]: typeParams[index] });\n          },\n          {}\n        );\n\n        return this._encodeRaw.call(\n          self,\n          new BcsWriter(options),\n          data,\n          typeParams,\n          typeMap\n        );\n      },\n      decode(self: BCS, data, typeParams) {\n        const typeMap = (generics as string[]).reduce(\n          (acc: any, value: string, index) => {\n            return Object.assign(acc, { [value]: typeParams[index] });\n          },\n          {}\n        );\n\n        return this._decodeRaw.call(\n          self,\n          new BcsReader(data),\n          typeParams,\n          typeMap\n        );\n      },\n\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      },\n    } as TypeInterface);\n\n    return this;\n  }\n\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  public registerAddressType(\n    name: string,\n    length: number,\n    encoding: Encoding | void = \"hex\"\n  ): BCS {\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data: string) {\n            return fromB64(data).reduce(\n              (writer, el) => writer.write8(el),\n              writer\n            );\n          },\n          function decodeAddress(reader) {\n            return toB64(reader.readBytes(length));\n          }\n        );\n      case \"hex\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data: string) {\n            return fromHEX(data).reduce(\n              (writer, el) => writer.write8(el),\n              writer\n            );\n          },\n          function decodeAddress(reader) {\n            return toHEX(reader.readBytes(length));\n          }\n        );\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  private registerVectorType(typeName: string): BCS {\n    let { name, params } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n\n    return this.registerType(\n      typeName,\n      function encodeVector(\n        this: BCS,\n        writer: BcsWriter,\n        data: any[],\n        typeParams: TypeName[],\n        typeMap\n      ) {\n        return writer.writeVec(data, (writer, el) => {\n          let elementType: TypeName = typeParams[0];\n          if (!elementType) {\n            throw new Error(\n              `Incorrect number of type parameters passed a to vector '${typeName}'`\n            );\n          }\n\n          let { name, params } = this.parseTypeName(elementType);\n          if (this.hasType(name)) {\n            return this.getTypeInterface(name)._encodeRaw.call(\n              this,\n              writer,\n              el,\n              params,\n              typeMap\n            );\n          }\n\n          if (!(name in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`\n            );\n          }\n\n          let { name: innerName, params: innerParams } = this.parseTypeName(\n            typeMap[name]\n          );\n\n          return this.getTypeInterface(innerName)._encodeRaw.call(\n            this,\n            writer,\n            el,\n            innerParams,\n            typeMap\n          );\n        });\n      },\n      function decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n        return reader.readVec((reader) => {\n          let elementType: TypeName = typeParams[0];\n          if (!elementType) {\n            throw new Error(\n              `Incorrect number of type parameters passed to a vector '${typeName}'`\n            );\n          }\n\n          let { name, params } = this.parseTypeName(elementType);\n          if (this.hasType(name)) {\n            return this.getTypeInterface(name)._decodeRaw.call(\n              this,\n              reader,\n              params,\n              typeMap\n            );\n          }\n\n          if (!(name in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`\n            );\n          }\n\n          let { name: innerName, params: innerParams } = this.parseTypeName(\n            typeMap[name]\n          );\n          this.getTypeInterface(innerName)._decodeRaw.call(\n            this,\n            reader,\n            innerParams,\n            typeMap\n          );\n        });\n      }\n    );\n  }\n\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  public registerStructType(\n    typeName: TypeName,\n    fields: StructTypeDefinition\n  ): BCS {\n    // When an Object is passed, we register it under a new key and store it\n    // in the registered type system. This way we allow nested inline definitions.\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n\n      // TODO: add a type guard here?\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value as StructTypeDefinition);\n      }\n    }\n\n    let struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n    // IMPORTANT: we need to store canonical order of fields for each registered\n    // struct so we maintain it and allow developers to use any field ordering in\n    // their code (and not cause mismatches based on field order).\n    let canonicalOrder = Object.keys(struct);\n\n    // Holds generics for the struct definition. At this stage we can check that\n    // generic parameter matches the one defined in the struct.\n    let { name: structName, params: generics } = this.parseTypeName(typeName);\n\n    // Make sure all the types in the fields description are already known\n    // and that all the field types are strings.\n    return this.registerType(\n      typeName,\n      function encodeStruct(\n        this: BCS,\n        writer: BcsWriter,\n        data: { [key: string]: any },\n        typeParams,\n        typeMap\n      ) {\n        if (!data || data.constructor !== Object) {\n          throw new Error(\n            `Expected ${structName} to be an Object, got: ${data}`\n          );\n        }\n\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n\n        // follow the canonical order when serializing\n        for (let key of canonicalOrder) {\n          if (!(key in data)) {\n            throw new Error(\n              `Struct ${structName} requires field ${key}:${struct[key]}`\n            );\n          }\n\n          // Before deserializing, read the canonical field type.\n          const { name: fieldType, params: fieldParams } = this.parseTypeName(\n            struct[key] as TypeName\n          );\n\n          // Check whether this type is a generic defined in this struct.\n          // If it is -> read the type parameter matching its index.\n          // If not - tread as a regular field.\n          if (!generics.includes(fieldType)) {\n            this.getTypeInterface(fieldType)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              fieldParams,\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldType);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n            // If the type from the type parameters already exists\n            // and known -> proceed with type decoding.\n            if (this.hasType(name)) {\n              this.getTypeInterface(name)._encodeRaw.call(\n                this,\n                writer,\n                data[key],\n                params as string[],\n                typeMap\n              );\n              continue;\n            }\n\n            // Alternatively, if it's a global generic parameter...\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n\n            let { name: innerName, params: innerParams } = this.parseTypeName(\n              typeMap[name]\n            );\n            this.getTypeInterface(innerName)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return writer;\n      },\n      function decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n\n        let result: { [key: string]: any } = {};\n        for (let key of canonicalOrder) {\n          const { name: fieldName, params: fieldParams } = this.parseTypeName(\n            struct[key] as TypeName\n          );\n\n          // if it's not a generic\n          if (!generics.includes(fieldName)) {\n            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n              this,\n              reader,\n              fieldParams as string[],\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldName);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n            // If the type from the type parameters already exists\n            // and known -> proceed with type decoding.\n            if (this.hasType(name)) {\n              result[key] = this.getTypeInterface(name)._decodeRaw.call(\n                this,\n                reader,\n                params,\n                typeMap\n              );\n              continue;\n            }\n\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n\n            let { name: innerName, params: innerParams } = this.parseTypeName(\n              typeMap[name]\n            );\n            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n              this,\n              reader,\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return result;\n      }\n    );\n  }\n\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  public registerEnumType(\n    typeName: TypeName,\n    variants: EnumTypeDefinition\n  ): BCS {\n    // When an Object is passed, we register it under a new key and store it\n    // in the registered type system. This way we allow nested inline definitions.\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n\n      if (\n        value !== null &&\n        !Array.isArray(value) &&\n        typeof value !== \"string\"\n      ) {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value as StructTypeDefinition);\n      }\n    }\n\n    let struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n    // IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n    let canonicalOrder = Object.keys(struct);\n\n    // Parse type parameters in advance to know the index of each generic parameter.\n    let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n    return this.registerType(\n      typeName,\n      function encodeEnum(\n        this: BCS,\n        writer: BcsWriter,\n        data: { [key: string]: any | null },\n        typeParams,\n        typeMap\n      ) {\n        if (!data) {\n          throw new Error(\n            `Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`\n          );\n        }\n        if (typeof data !== \"object\") {\n          throw new Error(\n            `Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n              \" | \"\n            )}\".\\nReceived: \"${JSON.stringify(data)}\"`\n          );\n        }\n\n        let key = Object.keys(data)[0];\n        if (key === undefined) {\n          throw new Error(\n            `Empty object passed as invariant of the enum \"${name}\"`\n          );\n        }\n\n        let orderByte = canonicalOrder.indexOf(key);\n        if (orderByte === -1) {\n          throw new Error(\n            `Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n              \" | \"\n            )}\"; received \"${key}\"`\n          );\n        }\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant] as TypeName | null;\n\n        // write order byte\n        writer.write8(orderByte);\n\n        // When { \"key\": null } - empty value for the invariant.\n        if (invariantType === null) {\n          return writer;\n        }\n\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam =\n          paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n        {\n          let { name, params } = this.parseTypeName(typeOrParam);\n          return this.getTypeInterface(name)._encodeRaw.call(\n            this,\n            writer,\n            data[key],\n            params,\n            typeMap\n          );\n        }\n      },\n      function decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n        let orderByte = reader.readULEB();\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant] as TypeName | null;\n\n        if (orderByte === -1) {\n          throw new Error(\n            `Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`\n          );\n        }\n\n        // Encode an empty value for the enum.\n        if (invariantType === null) {\n          return { [invariant]: true };\n        }\n\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam =\n          paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n        {\n          let { name, params } = this.parseTypeName(typeOrParam);\n          return {\n            [invariant]: this.getTypeInterface(name)._decodeRaw.call(\n              this,\n              reader,\n              params,\n              typeMap\n            ),\n          };\n        }\n      }\n    );\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  public getTypeInterface(type: string): TypeInterface {\n    let typeInterface = this.types.get(type);\n\n    // Special case - string means an alias.\n    // Goes through the alias chain and tracks recursion.\n    if (typeof typeInterface === \"string\") {\n      let chain: string[] = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(\n            `Recursive definition found: ${chain.join(\n              \" -> \"\n            )} -> ${typeInterface}`\n          );\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n\n    if (typeInterface === undefined) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n\n    return typeInterface;\n  }\n\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  public parseTypeName(name: TypeName): {\n    name: string;\n    params: TypeName[];\n  } {\n    if (Array.isArray(name)) {\n      let [typeName, ...params] = name;\n      return { name: typeName, params };\n    }\n\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n\n    // if there are no generics - exit gracefully.\n    if (l_bound === -1 && r_bound === -1) {\n      return { name: name, params: [] };\n    }\n\n    // if one of the bounds is not defined - throw an Error.\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n\n    let typeName = name.slice(0, l_bound);\n    let params = name\n      .slice(l_bound + 1, name.length - r_bound - 1)\n      .split(\",\")\n      .map((e) => e.trim());\n\n    return { name: typeName, params };\n  }\n}\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n  switch (encoding) {\n    case \"base58\":\n      return toB58(data);\n    case \"base64\":\n      return toB64(data);\n    case \"hex\":\n      return toHEX(data);\n    default:\n      throw new Error(\n        \"Unsupported encoding, supported values are: base64, hex\"\n      );\n  }\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n  switch (encoding) {\n    case \"base58\":\n      return fromB58(data);\n    case \"base64\":\n      return fromB64(data);\n    case \"hex\":\n      return fromHEX(data);\n    default:\n      throw new Error(\n        \"Unsupported encoding, supported values are: base64, hex\"\n      );\n  }\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n  bcs.registerType(\n    BCS.U8,\n    function (writer: BcsWriter, data) {\n      return writer.write8(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read8();\n    },\n    (u8) => u8 < 256\n  );\n\n  bcs.registerType(\n    BCS.U16,\n    function (writer: BcsWriter, data) {\n      return writer.write16(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read16();\n    },\n    (u16) => u16 < 65536\n  );\n\n  bcs.registerType(\n    BCS.U32,\n    function (writer: BcsWriter, data) {\n      return writer.write32(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read32();\n    },\n    (u32) => u32 <= 4294967296n\n  );\n\n  bcs.registerType(\n    BCS.U64,\n    function (writer: BcsWriter, data) {\n      return writer.write64(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read64();\n    }\n  );\n\n  bcs.registerType(\n    BCS.U128,\n    function (writer: BcsWriter, data: bigint) {\n      return writer.write128(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read128();\n    }\n  );\n\n  bcs.registerType(\n    BCS.U256,\n    function (writer: BcsWriter, data) {\n      return writer.write256(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read256();\n    }\n  );\n\n  bcs.registerType(\n    BCS.BOOL,\n    function (writer: BcsWriter, data) {\n      return writer.write8(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read8().toString(10) === \"1\";\n    }\n  );\n\n  bcs.registerType(\n    BCS.STRING,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(data), (writer, el) =>\n        writer.write8(el.charCodeAt(0))\n      );\n    },\n    function (reader: BcsReader) {\n      return reader\n        .readVec((reader) => reader.read8())\n        .map((el: bigint) => String.fromCharCode(Number(el)))\n        .join(\"\");\n    },\n    (_str: string) => true\n  );\n\n  bcs.registerType(\n    BCS.HEX,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(fromHEX(data)), (writer, el) =>\n        writer.write8(el)\n      );\n    },\n    function (reader: BcsReader) {\n      let bytes = reader.readVec((reader) => reader.read8());\n      return toHEX(new Uint8Array(bytes));\n    }\n  );\n\n  bcs.registerType(\n    BCS.BASE58,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(fromB58(data)), (writer, el) =>\n        writer.write8(el)\n      );\n    },\n    function (reader: BcsReader) {\n      let bytes = reader.readVec((reader) => reader.read8());\n      return toB58(new Uint8Array(bytes));\n    }\n  );\n\n  bcs.registerType(\n    BCS.BASE64,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(fromB64(data)), (writer, el) =>\n        writer.write8(el)\n      );\n    },\n    function (reader: BcsReader) {\n      let bytes = reader.readVec((reader) => reader.read8());\n      return toB64(new Uint8Array(bytes));\n    }\n  );\n}\n\nexport function getRustConfig(): BcsConfig {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\",\n  };\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\",\n  };\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\\\n|*|  Base64 / binary data / UTF-8 strings utilities\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\\*/\n\n/* Array of bytes to Base64 string decoding */\n\nfunction b64ToUint6(nChr: number) {\n  return nChr > 64 && nChr < 91\n    ? nChr - 65\n    : nChr > 96 && nChr < 123\n    ? nChr - 71\n    : nChr > 47 && nChr < 58\n    ? nChr + 4\n    : nChr === 43\n    ? 62\n    : nChr === 47\n    ? 63\n    : 0;\n}\n\nexport function fromB64(sBase64: string, nBlocksSize?: number): Uint8Array {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ''),\n    nInLen = sB64Enc.length,\n    nOutLen = nBlocksSize\n      ? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\n      : (nInLen * 3 + 1) >> 2,\n    taBytes = new Uint8Array(nOutLen);\n\n  for (\n    var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0;\n    nInIdx < nInLen;\n    nInIdx++\n  ) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n\n  return taBytes;\n}\n\n/* Base64 string to array encoding */\n\nfunction uint6ToB64(nUint6: number) {\n  return nUint6 < 26\n    ? nUint6 + 65\n    : nUint6 < 52\n    ? nUint6 + 71\n    : nUint6 < 62\n    ? nUint6 - 4\n    : nUint6 === 62\n    ? 43\n    : nUint6 === 63\n    ? 47\n    : 65;\n}\n\nexport function toB64(aBytes: Uint8Array): string {\n  var nMod3 = 2,\n    sB64Enc = '';\n\n  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    if (nIdx > 0 && ((nIdx * 4) / 3) % 76 === 0) {\n      sB64Enc += '';\n    }\n    nUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(\n        uint6ToB64((nUint24 >>> 18) & 63),\n        uint6ToB64((nUint24 >>> 12) & 63),\n        uint6ToB64((nUint24 >>> 6) & 63),\n        uint6ToB64(nUint24 & 63)\n      );\n      nUint24 = 0;\n    }\n  }\n\n  return (\n    sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) +\n    (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==')\n  );\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n  // @ts-ignore\n  let intArr = hexStr\n    .replace('0x', '')\n    .match(/.{1,2}/g)\n    .map(byte => parseInt(byte, 16));\n\n  if (intArr === null) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n\n  return Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n  return bytes.reduce(\n    (str, byte) => str + byte.toString(16).padStart(2, '0'),\n    ''\n  );\n}\n"],"mappings":"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","names":["bs58","writer","name","params","reader","typeName"]}