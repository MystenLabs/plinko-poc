{"version":3,"sources":["../src/index.ts","../src/storage.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  WalletAdapterList,\n  resolveAdapters,\n  WalletAdapter,\n  isWalletProvider,\n} from \"@mysten/wallet-adapter-base\";\nimport { localStorageAdapter, StorageAdapter } from \"./storage\";\nimport {\n  SuiSignAndExecuteTransactionBlockInput,\n  SuiSignMessageInput,\n  SuiSignTransactionBlockInput,\n  WalletAccount,\n} from \"@mysten/wallet-standard\";\n\nexport * from \"./storage\";\n\nexport interface WalletKitCoreOptions {\n  adapters: WalletAdapterList;\n  preferredWallets?: string[];\n  storageAdapter?: StorageAdapter;\n  storageKey?: string;\n}\n\nexport enum WalletKitCoreConnectionStatus {\n  DISCONNECTED = \"DISCONNECTED\",\n  CONNECTING = \"CONNECTING\",\n  CONNECTED = \"CONNECTED\",\n  // TODO: Figure out if this is really a separate status, or is just a piece of state alongside the `disconnected` state:\n  ERROR = \"ERROR\",\n}\n\nexport interface InternalWalletKitCoreState {\n  wallets: WalletAdapter[];\n  currentWallet: WalletAdapter | null;\n  accounts: readonly WalletAccount[];\n  currentAccount: WalletAccount | null;\n  status: WalletKitCoreConnectionStatus;\n}\n\nexport interface WalletKitCoreState extends InternalWalletKitCoreState {\n  isConnecting: boolean;\n  isConnected: boolean;\n  isError: boolean;\n}\n\ntype OptionalProperties<T extends Record<any, any>, U extends keyof T> = Omit<\n  T,\n  U\n> &\n  Partial<Pick<T, U>>;\n\nexport interface WalletKitCore {\n  autoconnect(): Promise<void>;\n  getState(): WalletKitCoreState;\n  subscribe(handler: SubscribeHandler): Unsubscribe;\n  connect(walletName: string): Promise<void>;\n  selectAccount(account: WalletAccount): void;\n  disconnect(): Promise<void>;\n  signMessage(\n    messageInput: OptionalProperties<SuiSignMessageInput, \"account\">\n  ): ReturnType<WalletAdapter[\"signMessage\"]>;\n  signTransactionBlock: (\n    transactionInput: OptionalProperties<\n      SuiSignTransactionBlockInput,\n      \"chain\" | \"account\"\n    >\n  ) => ReturnType<WalletAdapter[\"signTransactionBlock\"]>;\n  signAndExecuteTransactionBlock: (\n    transactionInput: OptionalProperties<\n      SuiSignAndExecuteTransactionBlockInput,\n      \"chain\" | \"account\"\n    >\n  ) => ReturnType<WalletAdapter[\"signAndExecuteTransactionBlock\"]>;\n}\n\nexport type SubscribeHandler = (state: WalletKitCoreState) => void;\nexport type Unsubscribe = () => void;\n\nconst SUI_WALLET_NAME = \"Sui Wallet\";\n\nconst RECENT_WALLET_STORAGE = \"wallet-kit:last-wallet\";\n\nfunction waitToBeVisible() {\n  if (!document || document.visibilityState === \"visible\") {\n    return Promise.resolve();\n  }\n  let promiseResolve: (() => void) | null = null;\n  const promise = new Promise<void>((r) => (promiseResolve = r));\n  const callback = () => {\n    if (promiseResolve && document.visibilityState === \"visible\") {\n      promiseResolve();\n      document.removeEventListener(\"visibilitychange\", callback);\n    }\n  };\n  document.addEventListener(\"visibilitychange\", callback);\n  return promise;\n}\n\nfunction sortWallets(wallets: WalletAdapter[], preferredWallets: string[]) {\n  return [\n    // Preferred wallets, in order:\n    ...(preferredWallets\n      .map((name) => wallets.find((wallet) => wallet.name === name))\n      .filter(Boolean) as WalletAdapter[]),\n\n    // Wallets in default order:\n    ...wallets.filter((wallet) => !preferredWallets.includes(wallet.name)),\n  ];\n}\n\n// TODO: Support lazy loaded adapters, where we'll resolve the adapters only once we attempt to use them.\n// That should allow us to have effective code-splitting practices. We should also allow lazy loading of _many_\n// wallet adapters in one bag so that we can split _all_ of the adapters from the core.\nexport function createWalletKitCore({\n  adapters,\n  preferredWallets = [SUI_WALLET_NAME],\n  storageAdapter = localStorageAdapter,\n  storageKey = RECENT_WALLET_STORAGE,\n}: WalletKitCoreOptions): WalletKitCore {\n  const subscriptions: Set<(state: WalletKitCoreState) => void> = new Set();\n  let walletEventUnsubscribe: (() => void) | null = null;\n\n  let internalState: InternalWalletKitCoreState = {\n    accounts: [],\n    currentAccount: null,\n    wallets: sortWallets(resolveAdapters(adapters), preferredWallets),\n    currentWallet: null,\n    status: WalletKitCoreConnectionStatus.DISCONNECTED,\n  };\n\n  const computeState = () => ({\n    ...internalState,\n    isConnecting:\n      internalState.status === WalletKitCoreConnectionStatus.CONNECTING,\n    isConnected:\n      internalState.status === WalletKitCoreConnectionStatus.CONNECTED,\n    isError: internalState.status === WalletKitCoreConnectionStatus.ERROR,\n  });\n\n  let state = computeState();\n\n  function setState(nextInternalState: Partial<InternalWalletKitCoreState>) {\n    internalState = {\n      ...internalState,\n      ...nextInternalState,\n    };\n    state = computeState();\n    subscriptions.forEach((handler) => {\n      try {\n        handler(state);\n      } catch {}\n    });\n  }\n\n  function disconnected() {\n    if (walletEventUnsubscribe) {\n      walletEventUnsubscribe();\n      walletEventUnsubscribe = null;\n    }\n    setState({\n      status: WalletKitCoreConnectionStatus.DISCONNECTED,\n      accounts: [],\n      currentAccount: null,\n      currentWallet: null,\n    });\n  }\n\n  // TODO: Defer this somehow, probably alongside the work above for lazy wallet adapters:\n  const providers = adapters.filter(isWalletProvider);\n  if (providers.length) {\n    providers.map((provider) =>\n      provider.on(\"changed\", () => {\n        setState({\n          wallets: sortWallets(resolveAdapters(adapters), preferredWallets),\n        });\n      })\n    );\n  }\n\n  const walletKit: WalletKitCore = {\n    async autoconnect() {\n      if (state.currentWallet) return;\n      await waitToBeVisible();\n      try {\n        const lastWalletName = await storageAdapter.get(storageKey);\n        if (lastWalletName) {\n          walletKit.connect(lastWalletName);\n        }\n      } catch {}\n    },\n\n    getState() {\n      return state;\n    },\n\n    subscribe(handler) {\n      subscriptions.add(handler);\n\n      // Immediately invoke the handler with the current state to make it compatible with Svelte stores:\n      try {\n        handler(state);\n      } catch {}\n\n      return () => {\n        subscriptions.delete(handler);\n      };\n    },\n\n    selectAccount(account) {\n      if (\n        account === internalState.currentAccount ||\n        !internalState.accounts.includes(account)\n      ) {\n        return;\n      }\n\n      setState({\n        currentAccount: account,\n      });\n    },\n\n    async connect(walletName) {\n      const currentWallet =\n        internalState.wallets.find((wallet) => wallet.name === walletName) ??\n        null;\n      // TODO: Should the current wallet actually be set before we successfully connect to it?\n      setState({ currentWallet });\n\n      if (currentWallet && !currentWallet.connecting) {\n        if (walletEventUnsubscribe) {\n          walletEventUnsubscribe();\n        }\n        walletEventUnsubscribe = currentWallet.on(\n          \"change\",\n          ({ connected, accounts }) => {\n            // when undefined connected hasn't changed\n            if (connected === false) {\n              disconnected();\n            } else if (accounts) {\n              setState({\n                accounts,\n                currentAccount:\n                  internalState.currentAccount &&\n                  !accounts.find(\n                    ({ address }) =>\n                      address === internalState.currentAccount?.address\n                  )\n                    ? accounts[0]\n                    : internalState.currentAccount,\n              });\n            }\n          }\n        );\n        try {\n          setState({ status: WalletKitCoreConnectionStatus.CONNECTING });\n          await currentWallet.connect();\n          setState({ status: WalletKitCoreConnectionStatus.CONNECTED });\n          try {\n            await storageAdapter.set(storageKey, currentWallet.name);\n          } catch {}\n          // TODO: Rather than using this method, we should just standardize the wallet properties on the adapter itself:\n          const accounts = await currentWallet.getAccounts();\n          // TODO: Implement account selection:\n\n          setState({ accounts, currentAccount: accounts[0] ?? null });\n        } catch (e) {\n          console.log(\"Wallet connection error\", e);\n\n          setState({ status: WalletKitCoreConnectionStatus.ERROR });\n        }\n      } else {\n        setState({ status: WalletKitCoreConnectionStatus.DISCONNECTED });\n      }\n    },\n\n    async disconnect() {\n      if (!internalState.currentWallet) {\n        console.warn(\"Attempted to `disconnect` but no wallet was connected.\");\n        return;\n      }\n      try {\n        await storageAdapter.del(storageKey);\n      } catch {}\n      await internalState.currentWallet.disconnect();\n      disconnected();\n    },\n\n    signMessage(messageInput) {\n      if (!internalState.currentWallet || !internalState.currentAccount) {\n        throw new Error(\n          \"No wallet is currently connected, cannot call `signMessage`.\"\n        );\n      }\n\n      return internalState.currentWallet.signMessage({\n        ...messageInput,\n        account: messageInput.account ?? internalState.currentAccount,\n      });\n    },\n\n    async signTransactionBlock(transactionInput) {\n      if (!internalState.currentWallet || !internalState.currentAccount) {\n        throw new Error(\n          \"No wallet is currently connected, cannot call `signTransaction`.\"\n        );\n      }\n      const {\n        account = internalState.currentAccount,\n        chain = internalState.currentAccount.chains[0],\n      } = transactionInput;\n      if (!chain) {\n        throw new Error(\"Missing chain\");\n      }\n      return internalState.currentWallet.signTransactionBlock({\n        ...transactionInput,\n        account,\n        chain,\n      });\n    },\n\n    async signAndExecuteTransactionBlock(transactionInput) {\n      if (!internalState.currentWallet || !internalState.currentAccount) {\n        throw new Error(\n          \"No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`.\"\n        );\n      }\n      const {\n        account = internalState.currentAccount,\n        chain = internalState.currentAccount.chains[0],\n      } = transactionInput;\n      if (!chain) {\n        throw new Error(\"Missing chain\");\n      }\n      return internalState.currentWallet.signAndExecuteTransactionBlock({\n        ...transactionInput,\n        account,\n        chain,\n      });\n    },\n  };\n\n  return walletKit;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface StorageAdapter {\n  set(key: string, value: string): Promise<void>;\n  get(key: string): Promise<string | undefined | null>;\n  del(key: string): Promise<void>;\n}\n\nexport const localStorageAdapter: StorageAdapter = {\n  async set(key, value) {\n    return localStorage.setItem(key, value);\n  },\n  async get(key) {\n    return localStorage.getItem(key);\n  },\n  async del(key) {\n    localStorage.removeItem(key);\n  },\n};\n\nexport const noopStorageAdapter: StorageAdapter = {\n  async set() {},\n  async get() {\n    return null;\n  },\n  async del() {},\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,iCAKO;;;ACCA,IAAM,sBAAsC;AAAA,EACjD,MAAM,IAAI,KAAK,OAAO;AACpB,WAAO,aAAa,QAAQ,KAAK,KAAK;AAAA,EACxC;AAAA,EACA,MAAM,IAAI,KAAK;AACb,WAAO,aAAa,QAAQ,GAAG;AAAA,EACjC;AAAA,EACA,MAAM,IAAI,KAAK;AACb,iBAAa,WAAW,GAAG;AAAA,EAC7B;AACF;AAEO,IAAM,qBAAqC;AAAA,EAChD,MAAM,MAAM;AAAA,EAAC;AAAA,EACb,MAAM,MAAM;AACV,WAAO;AAAA,EACT;AAAA,EACA,MAAM,MAAM;AAAA,EAAC;AACf;;;ADDO,IAAK,gCAAL,kBAAKA,mCAAL;AACL,EAAAA,+BAAA,kBAAe;AACf,EAAAA,+BAAA,gBAAa;AACb,EAAAA,+BAAA,eAAY;AAEZ,EAAAA,+BAAA,WAAQ;AALE,SAAAA;AAAA,GAAA;AAuDZ,IAAM,kBAAkB;AAExB,IAAM,wBAAwB;AAE9B,SAAS,kBAAkB;AACzB,MAAI,CAAC,YAAY,SAAS,oBAAoB,WAAW;AACvD,WAAO,QAAQ,QAAQ;AAAA,EACzB;AACA,MAAI,iBAAsC;AAC1C,QAAM,UAAU,IAAI,QAAc,CAAC,MAAO,iBAAiB,CAAE;AAC7D,QAAM,WAAW,MAAM;AACrB,QAAI,kBAAkB,SAAS,oBAAoB,WAAW;AAC5D,qBAAe;AACf,eAAS,oBAAoB,oBAAoB,QAAQ;AAAA,IAC3D;AAAA,EACF;AACA,WAAS,iBAAiB,oBAAoB,QAAQ;AACtD,SAAO;AACT;AAEA,SAAS,YAAY,SAA0B,kBAA4B;AACzE,SAAO;AAAA;AAAA,IAEL,GAAI,iBACD,IAAI,CAAC,SAAS,QAAQ,KAAK,CAAC,WAAW,OAAO,SAAS,IAAI,CAAC,EAC5D,OAAO,OAAO;AAAA;AAAA,IAGjB,GAAG,QAAQ,OAAO,CAAC,WAAW,CAAC,iBAAiB,SAAS,OAAO,IAAI,CAAC;AAAA,EACvE;AACF;AAKO,SAAS,oBAAoB;AAAA,EAClC;AAAA,EACA,mBAAmB,CAAC,eAAe;AAAA,EACnC,iBAAiB;AAAA,EACjB,aAAa;AACf,GAAwC;AACtC,QAAM,gBAA0D,oBAAI,IAAI;AACxE,MAAI,yBAA8C;AAElD,MAAI,gBAA4C;AAAA,IAC9C,UAAU,CAAC;AAAA,IACX,gBAAgB;AAAA,IAChB,SAAS,gBAAY,4CAAgB,QAAQ,GAAG,gBAAgB;AAAA,IAChE,eAAe;AAAA,IACf,QAAQ;AAAA,EACV;AAEA,QAAM,eAAe,OAAO;AAAA,IAC1B,GAAG;AAAA,IACH,cACE,cAAc,WAAW;AAAA,IAC3B,aACE,cAAc,WAAW;AAAA,IAC3B,SAAS,cAAc,WAAW;AAAA,EACpC;AAEA,MAAI,QAAQ,aAAa;AAEzB,WAAS,SAAS,mBAAwD;AACxE,oBAAgB;AAAA,MACd,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AACA,YAAQ,aAAa;AACrB,kBAAc,QAAQ,CAAC,YAAY;AACjC,UAAI;AACF,gBAAQ,KAAK;AAAA,MACf,QAAE;AAAA,MAAO;AAAA,IACX,CAAC;AAAA,EACH;AAEA,WAAS,eAAe;AACtB,QAAI,wBAAwB;AAC1B,6BAAuB;AACvB,+BAAyB;AAAA,IAC3B;AACA,aAAS;AAAA,MACP,QAAQ;AAAA,MACR,UAAU,CAAC;AAAA,MACX,gBAAgB;AAAA,MAChB,eAAe;AAAA,IACjB,CAAC;AAAA,EACH;AAGA,QAAM,YAAY,SAAS,OAAO,2CAAgB;AAClD,MAAI,UAAU,QAAQ;AACpB,cAAU;AAAA,MAAI,CAAC,aACb,SAAS,GAAG,WAAW,MAAM;AAC3B,iBAAS;AAAA,UACP,SAAS,gBAAY,4CAAgB,QAAQ,GAAG,gBAAgB;AAAA,QAClE,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,YAA2B;AAAA,IAC/B,MAAM,cAAc;AAClB,UAAI,MAAM;AAAe;AACzB,YAAM,gBAAgB;AACtB,UAAI;AACF,cAAM,iBAAiB,MAAM,eAAe,IAAI,UAAU;AAC1D,YAAI,gBAAgB;AAClB,oBAAU,QAAQ,cAAc;AAAA,QAClC;AAAA,MACF,QAAE;AAAA,MAAO;AAAA,IACX;AAAA,IAEA,WAAW;AACT,aAAO;AAAA,IACT;AAAA,IAEA,UAAU,SAAS;AACjB,oBAAc,IAAI,OAAO;AAGzB,UAAI;AACF,gBAAQ,KAAK;AAAA,MACf,QAAE;AAAA,MAAO;AAET,aAAO,MAAM;AACX,sBAAc,OAAO,OAAO;AAAA,MAC9B;AAAA,IACF;AAAA,IAEA,cAAc,SAAS;AACrB,UACE,YAAY,cAAc,kBAC1B,CAAC,cAAc,SAAS,SAAS,OAAO,GACxC;AACA;AAAA,MACF;AAEA,eAAS;AAAA,QACP,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,QAAQ,YAAY;AACxB,YAAM,gBACJ,cAAc,QAAQ,KAAK,CAAC,WAAW,OAAO,SAAS,UAAU,KACjE;AAEF,eAAS,EAAE,cAAc,CAAC;AAE1B,UAAI,iBAAiB,CAAC,cAAc,YAAY;AAC9C,YAAI,wBAAwB;AAC1B,iCAAuB;AAAA,QACzB;AACA,iCAAyB,cAAc;AAAA,UACrC;AAAA,UACA,CAAC,EAAE,WAAW,SAAS,MAAM;AAE3B,gBAAI,cAAc,OAAO;AACvB,2BAAa;AAAA,YACf,WAAW,UAAU;AACnB,uBAAS;AAAA,gBACP;AAAA,gBACA,gBACE,cAAc,kBACd,CAAC,SAAS;AAAA,kBACR,CAAC,EAAE,QAAQ,MACT,YAAY,cAAc,gBAAgB;AAAA,gBAC9C,IACI,SAAS,CAAC,IACV,cAAc;AAAA,cACtB,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AACA,YAAI;AACF,mBAAS,EAAE,QAAQ,8BAAyC,CAAC;AAC7D,gBAAM,cAAc,QAAQ;AAC5B,mBAAS,EAAE,QAAQ,4BAAwC,CAAC;AAC5D,cAAI;AACF,kBAAM,eAAe,IAAI,YAAY,cAAc,IAAI;AAAA,UACzD,QAAE;AAAA,UAAO;AAET,gBAAM,WAAW,MAAM,cAAc,YAAY;AAGjD,mBAAS,EAAE,UAAU,gBAAgB,SAAS,CAAC,KAAK,KAAK,CAAC;AAAA,QAC5D,SAAS,GAAP;AACA,kBAAQ,IAAI,2BAA2B,CAAC;AAExC,mBAAS,EAAE,QAAQ,oBAAoC,CAAC;AAAA,QAC1D;AAAA,MACF,OAAO;AACL,iBAAS,EAAE,QAAQ,kCAA2C,CAAC;AAAA,MACjE;AAAA,IACF;AAAA,IAEA,MAAM,aAAa;AACjB,UAAI,CAAC,cAAc,eAAe;AAChC,gBAAQ,KAAK,wDAAwD;AACrE;AAAA,MACF;AACA,UAAI;AACF,cAAM,eAAe,IAAI,UAAU;AAAA,MACrC,QAAE;AAAA,MAAO;AACT,YAAM,cAAc,cAAc,WAAW;AAC7C,mBAAa;AAAA,IACf;AAAA,IAEA,YAAY,cAAc;AACxB,UAAI,CAAC,cAAc,iBAAiB,CAAC,cAAc,gBAAgB;AACjE,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,aAAO,cAAc,cAAc,YAAY;AAAA,QAC7C,GAAG;AAAA,QACH,SAAS,aAAa,WAAW,cAAc;AAAA,MACjD,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,qBAAqB,kBAAkB;AAC3C,UAAI,CAAC,cAAc,iBAAiB,CAAC,cAAc,gBAAgB;AACjE,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,QACJ,UAAU,cAAc;AAAA,QACxB,QAAQ,cAAc,eAAe,OAAO,CAAC;AAAA,MAC/C,IAAI;AACJ,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,eAAe;AAAA,MACjC;AACA,aAAO,cAAc,cAAc,qBAAqB;AAAA,QACtD,GAAG;AAAA,QACH;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,IAEA,MAAM,+BAA+B,kBAAkB;AACrD,UAAI,CAAC,cAAc,iBAAiB,CAAC,cAAc,gBAAgB;AACjE,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,QACJ,UAAU,cAAc;AAAA,QACxB,QAAQ,cAAc,eAAe,OAAO,CAAC;AAAA,MAC/C,IAAI;AACJ,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,eAAe;AAAA,MACjC;AACA,aAAO,cAAc,cAAc,+BAA+B;AAAA,QAChE,GAAG;AAAA,QACH;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;","names":["WalletKitCoreConnectionStatus"]}