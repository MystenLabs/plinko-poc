// src/index.ts
import {
  resolveAdapters,
  isWalletProvider
} from "@mysten/wallet-adapter-base";

// src/storage.ts
var localStorageAdapter = {
  async set(key, value) {
    return localStorage.setItem(key, value);
  },
  async get(key) {
    return localStorage.getItem(key);
  },
  async del(key) {
    localStorage.removeItem(key);
  }
};
var noopStorageAdapter = {
  async set() {
  },
  async get() {
    return null;
  },
  async del() {
  }
};

// src/index.ts
var WalletKitCoreConnectionStatus = /* @__PURE__ */ ((WalletKitCoreConnectionStatus2) => {
  WalletKitCoreConnectionStatus2["DISCONNECTED"] = "DISCONNECTED";
  WalletKitCoreConnectionStatus2["CONNECTING"] = "CONNECTING";
  WalletKitCoreConnectionStatus2["CONNECTED"] = "CONNECTED";
  WalletKitCoreConnectionStatus2["ERROR"] = "ERROR";
  return WalletKitCoreConnectionStatus2;
})(WalletKitCoreConnectionStatus || {});
var SUI_WALLET_NAME = "Sui Wallet";
var RECENT_WALLET_STORAGE = "wallet-kit:last-wallet";
function waitToBeVisible() {
  if (!document || document.visibilityState === "visible") {
    return Promise.resolve();
  }
  let promiseResolve = null;
  const promise = new Promise((r) => promiseResolve = r);
  const callback = () => {
    if (promiseResolve && document.visibilityState === "visible") {
      promiseResolve();
      document.removeEventListener("visibilitychange", callback);
    }
  };
  document.addEventListener("visibilitychange", callback);
  return promise;
}
function sortWallets(wallets, preferredWallets) {
  return [
    // Preferred wallets, in order:
    ...preferredWallets.map((name) => wallets.find((wallet) => wallet.name === name)).filter(Boolean),
    // Wallets in default order:
    ...wallets.filter((wallet) => !preferredWallets.includes(wallet.name))
  ];
}
function createWalletKitCore({
  adapters,
  preferredWallets = [SUI_WALLET_NAME],
  storageAdapter = localStorageAdapter,
  storageKey = RECENT_WALLET_STORAGE
}) {
  const subscriptions = /* @__PURE__ */ new Set();
  let walletEventUnsubscribe = null;
  let internalState = {
    accounts: [],
    currentAccount: null,
    wallets: sortWallets(resolveAdapters(adapters), preferredWallets),
    currentWallet: null,
    status: "DISCONNECTED" /* DISCONNECTED */
  };
  const computeState = () => ({
    ...internalState,
    isConnecting: internalState.status === "CONNECTING" /* CONNECTING */,
    isConnected: internalState.status === "CONNECTED" /* CONNECTED */,
    isError: internalState.status === "ERROR" /* ERROR */
  });
  let state = computeState();
  function setState(nextInternalState) {
    internalState = {
      ...internalState,
      ...nextInternalState
    };
    state = computeState();
    subscriptions.forEach((handler) => {
      try {
        handler(state);
      } catch {
      }
    });
  }
  function disconnected() {
    if (walletEventUnsubscribe) {
      walletEventUnsubscribe();
      walletEventUnsubscribe = null;
    }
    setState({
      status: "DISCONNECTED" /* DISCONNECTED */,
      accounts: [],
      currentAccount: null,
      currentWallet: null
    });
  }
  const providers = adapters.filter(isWalletProvider);
  if (providers.length) {
    providers.map(
      (provider) => provider.on("changed", () => {
        setState({
          wallets: sortWallets(resolveAdapters(adapters), preferredWallets)
        });
      })
    );
  }
  const walletKit = {
    async autoconnect() {
      if (state.currentWallet)
        return;
      await waitToBeVisible();
      try {
        const lastWalletName = await storageAdapter.get(storageKey);
        if (lastWalletName) {
          walletKit.connect(lastWalletName);
        }
      } catch {
      }
    },
    getState() {
      return state;
    },
    subscribe(handler) {
      subscriptions.add(handler);
      try {
        handler(state);
      } catch {
      }
      return () => {
        subscriptions.delete(handler);
      };
    },
    selectAccount(account) {
      if (account === internalState.currentAccount || !internalState.accounts.includes(account)) {
        return;
      }
      setState({
        currentAccount: account
      });
    },
    async connect(walletName) {
      const currentWallet = internalState.wallets.find((wallet) => wallet.name === walletName) ?? null;
      setState({ currentWallet });
      if (currentWallet && !currentWallet.connecting) {
        if (walletEventUnsubscribe) {
          walletEventUnsubscribe();
        }
        walletEventUnsubscribe = currentWallet.on(
          "change",
          ({ connected, accounts }) => {
            if (connected === false) {
              disconnected();
            } else if (accounts) {
              setState({
                accounts,
                currentAccount: internalState.currentAccount && !accounts.find(
                  ({ address }) => address === internalState.currentAccount?.address
                ) ? accounts[0] : internalState.currentAccount
              });
            }
          }
        );
        try {
          setState({ status: "CONNECTING" /* CONNECTING */ });
          await currentWallet.connect();
          setState({ status: "CONNECTED" /* CONNECTED */ });
          try {
            await storageAdapter.set(storageKey, currentWallet.name);
          } catch {
          }
          const accounts = await currentWallet.getAccounts();
          setState({ accounts, currentAccount: accounts[0] ?? null });
        } catch (e) {
          console.log("Wallet connection error", e);
          setState({ status: "ERROR" /* ERROR */ });
        }
      } else {
        setState({ status: "DISCONNECTED" /* DISCONNECTED */ });
      }
    },
    async disconnect() {
      if (!internalState.currentWallet) {
        console.warn("Attempted to `disconnect` but no wallet was connected.");
        return;
      }
      try {
        await storageAdapter.del(storageKey);
      } catch {
      }
      await internalState.currentWallet.disconnect();
      disconnected();
    },
    signMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signMessage`."
        );
      }
      return internalState.currentWallet.signMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    async signTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signTransaction`."
        );
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.signTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    },
    async signAndExecuteTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`."
        );
      }
      const {
        account = internalState.currentAccount,
        chain = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.signAndExecuteTransactionBlock({
        ...transactionInput,
        account,
        chain
      });
    }
  };
  return walletKit;
}
export {
  WalletKitCoreConnectionStatus,
  createWalletKitCore,
  localStorageAdapter,
  noopStorageAdapter
};
//# sourceMappingURL=index.mjs.map